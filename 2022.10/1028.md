## 🖐OOP의 5원칙 (SOLID)

> < Clean Code >의 저자, 로버트 마틴이 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 마이클 패더스가 SOLID라는 약어로 소개한 것!
> 
> 
> 각각 **SRP(단일 책임 원칙), OCP(개방-폐쇄 원칙), LSP(리스코프 치환 원칙), ISP(인터페이스 분리 원칙), DIP(의존 역전 원칙),** 의 앞글자를 따서 만들어졌다. SOLID 원칙을 철저히 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 되는 것으로 알려져있다.
> 

### S (SRP : Single Responsibility Principle)

*한 클래스는 하나의 책임만 가져야 한다.*

하나의 모듈은 한 가지 책임을 가져야 한다는 것으로, 이것은 모듈이 변경되는 이유가 한가지여야 함을 의미한다. 여기서 변경의 이유가 한가지라는 것은 해당 모듈이 여러 대상 또는 액터들에 대해 책임을 가져서는 안되고, 오직 하나의 액터에 대해서만 책임을 져야 한다는 것을 의미한다.

만약 어떤 모듈이 여러 액터에 대해 책임을 가지고 있다면 여러 액터들로부터 변경에 대한 요구가 올 수 있으므로, 해당 모듈을 수정해야 하는 이유 역시 여러 개가 될 수 있다. 반면에 어떤 클래스가 단 하나의 책임 만을 갖고 있다면, **특정 액터로부터 변경을 특정할 수 있으므로 해당 클래스를 변경해야 하는 이유와 시점이 명확해진다.**

예제로 살펴보자.

```java
//안 좋은예
class UserSettings {
  constructor(user) {
    this.user = user;
  }

//User의 인증이 유효하면 setting을 변경할 수 있는 기능
  changeSettings(settings) {
    if (this.verifyCredentials()) {
      // ...
    }
  }

//User을 인증하는 기능
  verifyCredentials() { 
    // ...
  }
}
```

위의 예제에서 UserSetting이라는 Class에서는 현재 2가지 기능을 하고 있다. User의 인증과 그 인증이 유효하면 setting을 변경할 수 있는 기능들이 있다. 이와 같이  하나의 Class에 다양한 기능이 들어가,  단일 책임 원칙을 지키지 않았을 경우에는,해당 Class를 수정했을 때 다른 모듈에 어떠한 영향을 미치는지 그 범위를 추측하기 힘들 수 있다.

위에서의 기능을 아래와 같이 분리를 한다면 Class는 각자 하나의 기능만 담당하며 수정에도 용이해진다.

```java
//좋은 예
class UserAuth {
  constructor(user) {
    this.user = user;
  }

  verifyCredentials() {
    // ...
  }
}

class UserSettings {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(user);
  }

  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
      // ...
    }
  }
}
```

모든 Class는 하나의 책임만 가지며, 그 책임은 완전히 캡슐화되어야 함을 일컫는다. 곧 작성된 Class는 하나의 기능만 가지며, 그 Class가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어야 한다는 원칙이다.

이러한 **단일 책임 원칙의 장점**은 시스템이 커질수록 극대화되는데, 시스템이 커지면서 서로 많은 의존성을 갖게되는 상황에서 변경 요청이 오면 딱 1가지만 수정하면 되기 때문이다. 단일 책임 원칙을 적용하여 적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 추상화함으로써 애플리케이션의 변화에 손쉽게 대응할 수 있다.

---

### O (OCP : Open/Closed Principle)

*확장에는 열려(Open) 있으나, 변경(수정)에는 닫혀(Closed)있어야 한다.*

- 확장에 대해 열려 있다 : 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.
- 수정에 대해 닫혀 있다 : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.

이는 수정이 일어나더라도 **기존의 구성요소에서는 수정이 일어나지 않아야 하며, 쉽게 확장이 가능하여 재사용을 할 수 있도록 해야한다**는 의미이다. 여기에서 중요한 것은 **추상화와 다형성**이다.

객체 지향에서 다형성이란 여러 가지 형태를 가질 수 있는 능력을 의미한다. 이 원칙을 무시한다면 유연성, 재사용성, 유지보수성 등을 얻을 수 없다 라고 할 정도로 중요한 원칙이라고 볼 수 있다.

클래스를 설계할 때 `변할 부분과 변하지 않을 부분을 명확히 구분`해야 한다. 변할 수 있는 부분은 추상화하여 상속하는 클래스가 의존할 수 있게 코드를 작성한다.

그래디 부치에 의하면 **추상화란 ‘다른 모든 종류의 객체로부터 식별될 수 있는 객체의 본질적인 특징’** 이라고 정의한다. 이 ‘본질적인 특징’을 명확히 정의할 수 있어야 한다.

Interface란 이런 변하지 않을 본질적인 특징에 관한 약속이다. Interface의 한 예시로 게임 캐릭터들의 스킬이 있다. 캐릭터가 스킬을 습득해서 스킬 버튼이 활성화 되었을 경우 스킬이 어떤 내용인지는 모르더라도 버튼을 누를경우 캐릭터가 어떤 행동을 할것이라는 사실은 확실하다. 회전을 할 수도 있고, 점프를 할 수도 있을 것이다. 스킬의 자세한 내용은 레벨업을 하거나 전직을 하거나 하면서 달라질 수 있지만 버튼을 누르면 스킬이 나간다는 사실은 변하지 않는다. ⇒ 변하는 부분과 변하지 않는 부분이 잘 나뉘어있는 즉 interface의 좋은예

예제로 살펴보자.

다음과 같은 코드로 게임을 진행중이었다고 가정하자.

```java
class 캐릭터{
    public fun 베기(){
        print("🗡🗡🗡");
    }
    public fun 점프(){
        print("🤸‍♂️");
    }
}//Game
fun playGame(어떤캐릭터 : 캐릭터){
    어떤캐릭터.점프();
    어떤캐릭터.베기();
}
```

위 코드에서 업데이트를 통해 캐릭터에 수정이 생겨 베기 스킬을 없애고 회전베기로 변경되었다고 하자.

```java
class 캐릭터{
/*    public fun 베기(){
        print("🗡🗡🗡");
    }
*/
    public fun 회전베기(){
        print("⚔⚔⚔");
    }
    public fun 점프(){
        print("🤸‍♂️");
    }
}
```

위 코드를 그대로 playGame에 적용한다면 캐릭터.베기()에서 컴파일 에러가 날 것이다.

```java
//Game
fun playGame(어떤캐릭터 : 전사){
    어떤캐릭터.점프();
    어떤캐릭터.베기(); //에러!!
}
```

이렇듯 스킬은 변하기 아주 쉬움에도 불구하고 그대로 상속해버리면 문제가 발생하기 쉽다.

스킬 두개가 각각 Q와 W버튼을 눌렀을 때 반응한다고 가정하면 Q버튼과 W버튼을 누르는 동작은 절대 변하지 않는다. 이런 부분을 Interface로 만들어준다.

```java
interface 캐릭터 {
    fun QPressed()
    fun WPressed()
}
```

그리고 interface를 상속하여 캐릭터를 구현한다.

```java
class 어떤캐릭터 : 캐릭터 {
    override fun QPressed(){
        회전베기();
    }    override fun WPressed(){
	점프();
    }    private fun 회전베기(){
        print("⚔⚔⚔");
    }
    private fun 점프(){
        print("🤸‍♂️");
    }
}
```

위와같이 interface를 상속하여 변하는 부분과 변하지 않을 부분을 정확히 나누어 변할 수 있는 부분은 private으로 선언하여 접근할 수 없게 만들었다. 또한 스킬에 변동 사항이 생기더라도 게임 진행에 전혀 문제가 없을 것이다.이렇게 하면 확장에는 열려있되, 변경에는 닫히게 된다.

개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다. **추상화란 핵심적인 부분만 남기고, 불필요한 부분은 제거함으로써 복잡한 것을 간단히 하는 것이고, 추상화를 통해 변하지 않는 부분만 남김으로써 기능을 구체화하고 확장할 수 있다.** 변하지 않는 부분은 고정하고 변하는 부분을 생략하여 추상화함으로써 변경이 필요한 경우에 생략된 부분을 수정하여 개방-폐쇄의 원칙을 지킬 수 있다.

객체가 알아야 하는 지식이 많으면 결합도가 높아지고, 결합도가 높아질수록 개방-폐쇄의 원칙을 따르는 구조를 설계하기가 어려워진다. 추상화를 통해 변하는 것들은 숨기고 변하지 않는 것들에 의존하게 하면 우리는 기존의 코드 및 클래스들을 수정하지 않은 채로 애플리케이션을 확장할 수 있다. 그리고 이것이 개방 폐쇄의 원칙이 의미하는 것이다.

---

### L (LSP : Liskov’s Substitution Principle)

*프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.*

MIT 컴퓨터 공학 교수인 리스코브가 올바른 상속 관계의 특징을 정의하기 위해 제안한 설계 원칙으로 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것이다.

한마디로 **부모 클래스를 상속한 자식 클래스는 부모 클래스의 역할을 정확히 해내야한다**는 뜻이다. 정말 당연한 말이지만 좀 처럼 지켜지지 않는 원칙이다.

보통 부모 클래스의 메소드를 override하면서 문제가 발생합니다. 부모 클래스의 기존 메소드를 자식 클래스가 수정하면서 문제가 생기는 것이다. LSP를 지키는 가장 간단한 방법은 상속을 하되, override를 안하는 것입니다. 하지만 이게 무조건적인 방법은 아니다. 상속을 할 때 override가 필요하다면 기존 부모 클래스의 메소드가 하던 역할을 충실히 수행하고 기능의 추가만 신중하게 수행하면 된다.

LSP는 결국 상속의 과정 중 메소드의 재정의가 필요하다면 현재 `자식 클래스가 부모 클래스의 기존 메소드의 의미를 해치지는 않는지` 신중히 고민하고 올바르게 상속하라는 의미이다.

예제로 살펴보자.

```java
//리스코프 치환 원칙에 대해 이해하기 위한 대표적인 예시인 정사각형은 직사각형이다(Square is a Rectangle)라는 예시이다. 직사각형과 정사각형을 각각 구현하면 다음과 같다.

@Getter
@Setter
@AllArgsConstructor
public class **Rectangle** {

    private int width, height;

    public int getArea() {
        return width * height;
    }

}

```

```java
public class **Square** extends Rectangle {

    public Square(int size) {
        super(size, size);
    }

    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width);
    }

    @Override
    public void setHeight(int height) {
        super.setWidth(height);
        super.setHeight(height);
    }
}
```

Square는 1개의 변수만을 생성자로 받으며, width나 height 1개 만을 설정하는 경우 모두 설정되도록 메소드가 오버라이딩 되어 있다. 이를 이용하는 클라이언트는 당연히 직사각형의 너비와 높이가 다르다고 가정할 것이고, 직사각형을 resize()하기를 원하는 경우 다음과 같은 메소드를 만들어 너비와 높이를 수정할 것이다. (항상 클라이언트의 입장에서 생각해야 함에 유의해야 한다.)

```java
public void resize(Rectangle rectangle, int width, int height) {
    rectangle.setWidth(width);
    rectangle.setHeight(height);
    if (rectangle.getWidth() != width && rectangle.getHeight() != height) {
        throw new IllegalStateException();
    }
}
```

문제는 resize()의 파라미터로 정사각형인 Square이 전달되는 경우다. Rectangle은 Square의 부모 클래스이므로 Square 역시 전달이 가능한데, Square는 가로와 세로가 모두 동일하게 설정되므로 예를 들어 다음과 같은 메소드를 호출하면 문제가 발생할 것이다.

```java
Rectangle rectangle = new Square();
resize(rectangle, 100, 150);
```

이러한 케이스는 명백히 클라이언트의 관점에서 부모 클래스와 자식 클래스의 행동이 호환되지 않으므로 리스코프 치환 원칙을 위반하는 경우이다. 리스코프 치환 원칙이 성립한다는 것은 자식 클래스가 부모 클래스 대신 사용될 수 있어야 하기 때문이다.
리스코프 치환 원칙은 **자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것**을 강조한다. 
위의 예시에서 클라이언트는 직사각형의 너비와 높이는 다를 것이라고 가정하는데, 정사각형은 이를 준수하지 못한다. 우리는 여기서 **대체 가능성을 결정해야 하는 것은 해당 객체를 이용하는 클라이언트**임을 반드시 잊지 말아야 한다.
이러한 문제를 해결하기 위해 빈 메소드를 호출하도록 하거나 호출 시에 에러를 던지는 등의 조치를 취할 수 있다. 하지만 이러한 방법은 클라이언트가 예상하지 못할 수 있으므로 추상화 레벨을 맞춰서 메소드 호출이 불가능하도록 하거나(Square은 resize를 호출하지 못하게 하거나) 해당 추상화 레벨에 맞게 메소드를 오버라이딩 하는게 합리적일 것이다.

---

### I (ISP : Interface Segregation Principle)

*특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.*

- 객체가 충분히 높은 응집도의 작은 단위로 설계됐더라도, 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절하게 분리해줄 필요가 있는데, 이를 인터페이스 분리 원칙이라고 부른다. 즉, 인터페이스 분리 원칙이란 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이다.
- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙이다. 다시 말하면, 하나의 큰 인터페이스를 상속 받기 보다는 인터페이스를 구체적이고 작은 단위들로 분리시켜 `꼭 필요한 인터페이스만 상속하자`는 의미이다.
SRP가 클래스의 단일책임을 강조했다면 **ISP는 인터페이스의 단일책임을 강조**합니다.
**인터페이스 하나의 크기가 크다는 것은 한번에 지켜야 할 약속이 많아진다는 것**을 의미합니다.
- 인터페이스 분리 원칙을 준수함으로써 **모든 클라이언트가 자신의 관심에 맞는 퍼블릭 인터페이스(외부에서 접근 가능한 메세지)만을 접근하여 불필요한 간섭을 최소화**할 수 있으며, 기존 클라이언트에 영향을 주지 않은 채로 유연하게 객체의 기능을 확장하거나 수정할 수 있다.
- 인터페이스 분리 원칙을 지킨다는 것은 어떤 구현체에 부가 기능이 필요하다면 이 인터페이스를 구현하는 다른 인터페이스를 만들어서 해결할 수 있다. 예를 들어 파일 읽기/쓰기 기능을 갖는 구현 클래스가 있는데 어떤 클라이언트는 읽기 작업 만을 필요로 한다면 별도의 읽기 인터페이스를 만들어 제공해주는 것이다.

---

### D (DIP : Dependency Inversion Principle)

*추상화에 의존한다. 구체화에 의존하면 안된다.*

의존 역전 원칙이란 고수준 모듈(상위 모듈)은 저수준 모듈(하위 모듈)의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다는 것이다. 객체 지향 프로그래밍에서는 객체들 사이에 메세지를 주고 받기 위해 의존성이 생기는데, 의존성 역전의 원칙은 올바른 의존 관계를 위한 원칙에 해당된다. 여기서 각각 고수준 모듈과 저수준 모듈이란 다음을 의미한다.

- 고수준 모듈: 변경이 없는 추상화된 클래스(또는 인터페이스)
- 저수준 모듈: 변하기 쉬운 구체 클래스의존 역전 원칙이란 결국 추상화에 의존하며 구체화에는 의존하지 않는 설계 원칙을 의미한다.

클래스 사이에는 의존관계가 존재하기 마련이다. 다만 의존 관계가 존재하되, 구체적인 클래스에 의존하지 말고 **최대한 추상화한 클래스에 의존**하라는 뜻이다. 다시 말하면 **interface를 적극적으로 활용**하라는 의미이기도 하다.

예제로 살펴보자.

사용자가 존재하고 사용자는 아이폰을 사용한다.

```java
class 아이폰 {
		fun 전화(){
     print("📞📞📞")
    }
		fun 검색(){
     print("🔎🔎🔎")
   }
}

class 사용자 {
	val 내폰 = 아이폰()
	fun 전화(){
    내폰.전화()
   }
	fun 검색(){
    내폰.검색()
   }
}
```

위 예시 코드에서 사용자는 아이폰 클래스에 의존하고 있다. 그리고 아이폰 클래스는 구체적인 클래스이기 때문에 변화에 취약하다. 만약 사용자가 아이폰을 다른 스마트폰으로 바꾸고 싶어한다면 코드에 상당한 변화가 필요할 것이다.

이 취약한 구조를 개선하기 위해 의존성을 역전시킬 필요가 있다. 현재 사용자가 의존하고 있는 아이폰 클래스를 덜 구체적인 추상화된 클래스로 만드는 것이다.

스마트폰이라는 추상화된 interface를 각종 구체화된 클래스들이 상속하고 사용자는 스마트폰 interface에 의존한다. `'구체적인 것은 추상화에 의존해야한다.'`는 말의 의미를 알 수있다.

기존에 사용자 클래스(상위 계층 = 정책 결정)가 아이폰 클래스(하위 계층 = 세부 사항)에 의존하던 상황을 반전시켜서 구현으로부터 독립되었다. 이제 사용자와 아이폰 모두 추상화에 의존하는 상황으로 바뀐것이다. 마침내 `'상위 모듈은 하위 모듈에 의존해서는 안된다. 둘 다 추상화에 의존해야한다.'`는 말의 의미가 제대로 이해가 된다.

코드는 다음과 같이 바꿀 수 있다.

```java
interface 스마트폰 {
    fun 전화()
    fun 검색()
}
class 아이폰 : 스마트폰 {
		override 
		fun 전화(){
	    print("📞📞📞")
	 }
		override 
		fun 검색(){
		   print("🔎🔎🔎")
   }
}
class 사용자(내폰 : 스마트폰){
		fun 전화(){
	    내폰.전화()
    }
		fun 검색(){
	    내폰.검색()
    }
}//실제 사용
val 나 = 사용자(object : 아이폰())
나.전화()
나.검색()
```

이렇게 의존하는 클래스를 추상화하고 외부에서 주입함으로써 외부 변동에 유연하게 대처할 수 있는 코드로 개선되었다. 의존성 역전의 원칙을 적용하여 의존성 주입이라는 이점까지 취할 수 있게 되었다.

<aside>
🙋🏻‍♀️ 5가지의 객체 지향 설계 원칙인 SOLID가 얘기하는 핵심은 결국 추상화이다. 구체 클래스에 의존하지 않고 추상 클래스(또는 인터페이스)에 의존함으로써 우리는 유연하고 확장가능한 애플리케이션을 만들 수 있는 것이다.

</aside>
