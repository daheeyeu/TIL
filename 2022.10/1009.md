- 🙋🏻‍♀️ **메소드와 생성자의 같은점, 다른점**
    
    ```
    ✅ **메소드**
    동작 ,객체간의 데이터 전달 수단
    외부로부터 매개값 받을수 있음
    리턴값 있음 (void 라도있음) ️
    
    ✅ **생성자**
    필드를 초기화 하기 위함
    메소드를 호출해서 사용준비
    메소드가 아니므로 반환값은 void 조차 허용되지 않으며, 아예 반환값이란 있을 수 없다. 또한, 생성자의 이름은 메소드와는 달리 반드시 클래스 이름하고 같아야 한다.
    생성자는 자바 클래스의 멤버가 아니며, 멤버가 아니므로 상속되지 않는다. 따라서, 오버라이딩의 대상이 될 수도 없다. 또한, 일반적인 메소드 호출방법으로 호출할 수 없다.
    생성자는 접근 제한 수식어인 public, protected, private 만을 쓸 수 있으며, abstract, final, native, static, strictfp, synchronized 등의 수식어를 사용할 수 없다.
    같은 시그너쳐(즉, 동일한 파라미터 순서)를 가진 생성자는 선언될 수 없으며, 컴파일 시에 에러가 발생한다.
    생성자는 throws 리스트를 통해 발생될 예외 리스트를 가질 수 있다. 이것은 일반 메소드와 동일한 개념과 방법으로 사용된다. new 표현식으로 객체를 생성할 때 생성자가 호출되므로, 그때 throws 리스트의 예외가 발생할 수 있게 된다.
    ```
    
- **🙋🏻‍♀️ 생성자의  작성 위치**
    
    클래스 내부 메소드 보다 위에 선언하는게 좋다.
    클래스 만들기 → 인스턴스 변수 선언 → 생성자 작성 → 메소드 작성
    : 이렇게 꼭 해야하는 건 아니지만, 누가 해당소스코드를 봐도 생성자를 바로 찾을 수 있다.
    
    🙋🏻‍♀️ 참조자료형과 기본자료형의 차이
    **기본 자료형 (primitive data type)**

<aside>
💡 자바 컴파일러에 의해 해석되는 자료형태를 기본 자료형이라고 한다.
총 8가지의 기본형을 미리 정의하고 제공한다.

- 기본 자료형은 반드시 사용하기 전에 선언(Declared)되야 한다.
- OS(운영체제)에 따라 자료형의 길이가 변하지 않는다.
- 비객체 타입이다. 따라서, null 값을 가질 수 없다.만약 기본형에 null을 넣고 싶다면, Wrapper Class를 활용해야 한다.
- 스택(Stack) 메모리에 저장된다.
</aside>

- 논리형 : boolean
- 문자형 : char
- 정수형 : byte, short, int, long
- 실수형 : float, double

→ 기본자료형은 `Pass by Value` 로 값만 전달한다.복제술처럼 메소드의 매개변수로 넘길때는 원래값은 놔두고, 전달되는 값이 진짜인것 처럼 보이게 한다. 매개변수를 받은 메소드에서 그 값을 어떻게 사용하던 간에 원래의 값은 변하지않는다.(호출되기 전과 후에 데이터가 변경되지 않음)

**참조 자료형 (reference data type)**

<aside>
💡 JAVA에서 기본형(Primitive type)을 제외한 타입들이 모두 참조형(Reference type) 이다. 참조형(Reference type)은 JAVA에서 최상인 **java.lang.Object**클래스를 상속하는 모든 클래스들을 말한다.

- 빈 객체를 의미하는 Null이 존재한다.
- 문법상으로는 에러가 없지만 실행시켰을 때 에러가 나는 런타임 에러가 발생한다.
    - 예) 객체나 배열을 Null 값으로 받으면 NullPointException이 발생하므로 변수 값을 넣어야 한다.
- new로 인하여 생성하는 것들은 메모리 영역인 Heap 영역에 생성을 하게되고, Garbage Collector가 돌면서 메모리를 해제한다.
- Heap 메모리에 생성된 인스턴스는 메소드나 각종 인터페이스에서 접근하기 위해 JVM의 Stack 영역에 존재하는 Frame에 일종의 포인터(C의 포인터와는 다르다)인 참조값을 가지고 있어 이를 통해 인스턴스를 핸들링한다.
</aside>
- class type (클래스)
- interface type (인터페이스)
- array type (배열)
- enum type (열거)
- 기타..

→ 참조자료형은 `Pass by reference` 로 데이터를 전달한다. (값value가 아니라 객체에 대한 참조 reference가 넘어가는 것)
`Pass by reference` 로 값이 전달되면 , 기본자료형`Pass by Value`과는 달리 호출한 메소드의 데이터에도 영향이 있다. 만약 매개변수로 받은 참조 자료형 안에 있는 객체를 변경하면 , 호출된 참조 자료형 안에 있는 객체는 호출된 메소드에서 변경한 대로 데이터가 바뀐다. 

**String Class (문자열)**

<aside>
💡 String Class는 참조형에 속하지만 기본적인 사용은 기본형 처럼 사용한다.

**[특징]**

- 불변(immutable)하는 객체이다.
- String 클래스에는 값을 변경해주는 메소드들이 존재하지만, 해당 메소드를 통해 데이터를 바꾼다 해도 새로운 String 클래스 객체를 만들어내는 것이다.
- 일반적으로 기본자료형의 비교는 == 연산자를 사용하지만String 객체간의 비교는 .equals() 메소드를 사용해야 한다.
</aside>
- **🙋🏻‍♀️ DTO란? 장점**
    
    **DTO란** Data Transfer Object의 약자로, 어떤 속성을 갖는 클래스를 만들고, 그 속성들을 쉽게 전달하기 위한 자바 패턴 중 하나를 의미한다.
    
    - **🙋🏻‍♀️ 프로그래밍에서 패턴의 의미는?**
        
        프로그래밍에서 패턴은 비슷한 기능을 하는 규칙에 하나의 이름을 정해 놓은 것을 의미한다.
        
    
    **DTO의 특징과 장점**
    
    1. DTO는 데이터 접근 메서드 외 기능을 가지고 있지 않는다. (getter, setter 메서드 외에 비즈니스 로직을 가지지 않는다.)
    - 정렬, 직렬화 등 데이터 표현을 위한 기능은 가질 수 있다.
    2. 값을 유연하게 변경할 수 있다. (가변성, mutable)
    3. 데이터 캡슐화를 통해 유연한 대응이 가능하다.
    - 데이터 요청 수 감소 효과
    
    **VO란?**
    Value Object의 약자로 **값을 가지는 객체를 의미함
    
    V**O의 특징과 장점**
    
    1. 변하지 않는 값을 가지는 객체(불변성, immutable)
    - 값이 변하지 않음을 보장하며 코드의 안정성과 생산성을 높임
    
    2. 값이 같다면 동일한 객체
    
    - 각 객체를 비교하는데 사용되는 ID가 없음
    - 같은 객체인지 판단하기 위해 각 속성들의 값을 비교함
    - equals() 메서드와 hashCode() 메서드를 오버라이드해서 객체 비교를 구현함
    - 🙋🏻‍♀️ **DTO와 VO의 공통점과 차이점**
        
        **공통점**
        
        - 레이어 간 데이터를 전달할 때 사용 가능
        - VO는 불변을 보장하기 때문에 데이터 전달 용도로 사용 가능
        
        **차이점**
        
        | DTO | VO |
        | --- | --- |
        | 값이 변할 수 있음 (가변 객체) | 값이 변하지 않음 (불변 객체) |
        | 레이어와 레이어 사이에서 사용 가능 | 모든 레이어에서 사용 가능 |
        | 내부의 속성(필드)값이 같아도 다른 객체로 식별 | 내부의 속성(필드)값들이 같다면 같은 객체로 식별 |
        | 데이터 접근 이외의 기능을 가지지 않음 | 특정 비즈니스 로직을 가질 수 없음 |
