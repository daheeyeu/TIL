# ☑️ Blocking & Non-blocking / sync & Async

## Blocking & Non-blocking

---

<aside>
🗣 다른 주체가 작업 할 때 자신의 제어권이 있는지 없는지로 볼 수 있다.

</aside>

### #블로킹 Blocking

- 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 **다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것**
- A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 제어권을 돌려주지 않는 것

### #논블로킹 Non-blocking

- 다른 주체의 작업에 **관련없이** 자신의 작업을 하는 것
- A 함수가 B 함수를 호출 할 때, B 함수가 제어권을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것.

## sync & Async

---

<aside>
🗣 결과를 돌려주었을 때 순서와 결과에 관심이 있는지 아닌지로 판단할 수 있다.

</aside>

### #동기 Synchronous

- 작업을 동시에 수행하거나, 동시에 끝나거나 , 끝나는 동시에 시작함을 의미
- A와 B가 시작 시간 또는 종료 시간이 일치하면 동기이다.
    

    - A, B 쓰레드가 동시에 작업을 시작하는 경우 (예를 들면 자바에서 CyclicBarrier)
    - 메서드 리턴 시간(A)과 결과를 전달받는 시간(B)이 일치하는 경우
- A가 끝나는 시간과 B가 시작하는 시간이 같으면 동기이다. 예를 들어 자바에서 `synchronized`
와 BlockingQueue가 위와 같은 경우이다.
    
    

### #비동기 Asynchronous

- 시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음을 의미
- 동기와 반대로 대상이 서로 시간을 맞추지 않는 것을 말한다. 예를 들어 호출하는 함수가 호출되는 함수에게 작업을 맡겨놓고 신경을 쓰지 않는 것을 말한다.
- A 함수가 B 함수를 호출 할 때, B 함수의 결과를 B 함수가 처리하는 것. (callback)

<aside>
🗣 sync & Async는 순서와 결과(처리)의 관점 ,Blocking & Non-blocking은 제어의 관점

</aside>

 **Blocking 이면 반드시 Sync 가 아니고, Non-blocking 이면 반드시 async 도 아니라는 점**이다. 그 말인 즉슨, Blocking / Non-blocking 과 Sync / Async 는 다른 개념이라는 것이다. Blocking / Non-blocking 과 Sync / Async 는 '관점'을 어떻게 두느냐에 따라 다르다고 할 수 있겠다.

# ☑️ Sync-Blocking 모델과 Async-Nonblocking 모델


- **Sync-Blocking 모델**
    - 자바에서 입력요청을 할 때 Sync-Blocking를 사용한다. 제어권이  넘어 갔기 때문에 아래 내용이 실행이 되지 않고 있다.
   
    입력을 하면 제어권과 결과를 같이 받아서 처리한다.
    
    
- **Async-Non blocking**
    - A가 B에게 작업 완료 후 실행하기를 원하는 콜백 함수를 같이 넘겨준다면(Async-Non-Blocking), A는 해당 작업에 대해 신경쓰지 않고 자신의 일을 끊김 없이 쭉 진행하고, B도 작업이 완료된 후 A가 넘겨준 콜백 함수를 수행한다.
    - 리소스를 효율적으로 사용하는 모델
        
        A는 B에게 요청한 일에 대해 요청만 한 후 신경 끄고 자기 일을 계속 할 수 있고, B도 알아서 요청 받은 일이 끝나면 콜백 함수로 작업의 마무리를 지으면 되기 때문이다. 동기가 아니기에 서로 계속 신호를 주고 받으며 완료 여부를 체크하는 리소스도 필요 없게 된다.
        

# ☑️ Sync-Non blocking 모델


여기서 부터 일반적인 케이스가 아니라는 생각이 들 수 있어서 어려울 수 있다.하지만 위에서 간단히 요약한 4가지 개념의 특성을 적용하면 의외로 이해가 간다.

- **Non-blocking** : A 함수가 B 함수를 호출 한 뒤, B 함수가 A 함수에게 제어권을 바로 돌려준다.
- **Synchronous** : A 함수가 B 함수를 호출 할 때, B 함수의 결과를 A 함수가 처리하는 것.

조합해보면 B 함수가 바로 제어권을 돌려주기에 A 함수는 다른 작업을 수행할 수 있지만,언제 종료되는지 알 수 없는 B 함수의 종료를 A 함수가 처리해야 한다.A 함수가 직접 결과를 처리해야하는 상황이기에 B 함수의 종료를 반복적으로 물어봐야 하는 경우이다.

- 다른일을 하며 중간중간마다 결과를 물어본다.
- 결과가 나오면 바로 처리한다.
- Sync-Blocking와 큰 차이가 없다.
- 게임에서 맵을 넘어갈 때 사용한다. 해당 데이터를 가져올 때까지 유저에게 정보의 로드율이 얼마만큼인지를 보여줘야 할 때

# ☑️ Async-Blocking 모델



- 보통 Async-Nonblocking로 하려다가 개발자의 실수로 혹은 기타 이유로 이와 같이 동작하는 경우가 있다.

### 정리

- Synchronous VS Asynchronous
    - 두 가지 이상의 대상(메서드, 작업, 처리 등)과 이를 처리하는 시간으로 구분한다.
    - **Synchronous**: 호출된 함수의 리턴하는 시간과 결과를 반환하는 시간이 일치하는 경우
    - **Asynchronous**: 호출된 함수의 리턴하는 시간과 결과를 반환하는 시간이 일치하지 않는 경우
- Blocking VS Non-Blocking
    - 호출되는 대상이 직접 제어할 수 없는 경우 이를 구분할 수 있다.
    - **Blocking**: 직접 제어할 수 없는 대상의 작업이 끝날 때까지 기다려야 하는 경우
    - **Non-Blocking**: 직접 제어할 수 없는 대상의 작업이 완료되기 전에 제어권을 넘겨주는 경우
    
  

## ☑️  IO와 NIO의 차이점에서 Blocking & Non-blocking / sync & Async


- **IO 스트림 - Blocking , Async**
    - 입력 스트림의 read() 메소드를 호출하면 데이터가 입력되기 전까지 스레드는 Blocking (대기상태)된다.
    - 출력 스트림의 write() 메소드를 호출하면 데이터가 출력되기 전까지 스레드는 Blocking 된다.
    - 스레드가 블로킹되면 다른 일을 할 수가 없고 interrupt 해서 블로킹을 빠져나올 수도 없다.
    - 블로킹을 빠져나오는 유일한 방법은 스트림을 닫는 것이다.
    - IO는 동기 방식으로 동작을 한다. 그래서 IO에 있는 API를 호출하게 되면 그 API가 작업을 다 마쳐야 다음 코드를 실행 할 수가 있다.
- **NIO채널 - Blocking & Non-blocking, sync & Async**
    - NIO 블로킹은 스레드를 interrupt 함으로써 빠져나올 수 있다.
    - NIO는 Non-blocking을 지원하는데, 입출력 작업시 스레드가 블로킹되지 않는다. = 대기상태 없이 API 사용 가능
    - NIO는 IO와 달리 동기와 비동기를 모두 지원한다. 비동기는 NIO의 API를 호출하고 나서 즉시 다른 작업을 할 수 있다.

