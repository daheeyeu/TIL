## ☑️ **HTTP** 란 무엇인가?

---

### **[ HTTP(Hyper Text Transfer Protocol)란? ]**

HTTP(Hyper Text Transfer Protocol)란 서버와 클라이언트간에 데이터를 주고 받는 프로토콜이다.
HTTP는 텍스트, 이미지,영상, JSON 등등 거의 **모든 형태의 데이터**를 전송할수 있다.

즉, HTTP는 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로, 80번 포트를 사용하고 있다. 따라서 HTTP 서버가 80번 포트에서 요청을 기다리고 있으며, 클라이언트는 80번 포트로 요청을 보내게 된다.

HTTP는 1989년 팀 버너스 리(Tim Berners Lee)에 의해 처음 설계되었으며, WWW(World-Wide-Web) 기반에서 세계적인 정보를 공유하는데 큰 역할을 하였다.

### **[ HTTP의 구조 ]**

HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성된다.


하지만 HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이였기 때문에, HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제3자가 정보를 조회할 수 있었다. 그리고 이러한 문제를 해결하기 위해 HTTPS가 등장하게 되었다.

## ☑️ **HTTP** 와 **HTTP**2 의 차이는?

---


가장 큰 차이는 속도이다. 2.0은 헤더를 압축해서 보내기도 하고, 한번의 연결로 동시에 에러메시지를 주고 받을 수도 있다.

## HTTP 1.1 특징 (문제점)

- Connection 한 개당 하나의 요청을 처리하도록 설계됨> 동시에 리소스를 주고 받는 것이 불가능> 요청과 응답이 순차적으로 이루어짐> HTTP 문서 내에 포함된 다수의 리소스(image, css, script)를 처리하려면 요청할 리소스의 개수에 비례하여 Latency(대기시간)이 길어짐
- HOL(Head Of Line) Blocking이 발생할 수 있다.HOL 블로킹이란 네트워크에서 같은 큐에 있는 패킷이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말한다.
- RTT(Round Trip Time) 증가Connection 하나에 요청 한 개를 처리하는 특성때문에 매번 요청 별로 Connection을 만들게 되고 TCP상에서 동작하는 HTTP의 특성상 3-way handshake가 반복적으로 일어나며, 불필요한 RTT 증가와 네트워크 지연을 초래하여 성능을 지연시킨다.
- 무거운 Header 구조매 요청마다 중복된 헤더 값을 전송하게 되며, 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송된다. 이러한 반복적인 헤더 전송, 쿠키 정보로 인해 헤더 크기가 증가한다.

## HTTP1.1 개선방법

1. Image Spriting: 웹 페이지를 구성하는 다양한 아이콘 이미지 파일의 요청 횟수를 줄이기 위해 아이콘을 하나의 큰 이미지로 만든 다음 CSS에서 해당 이미지의 좌표 값을 지정하여 표시하는 방법이다.
2. Domain Sharding브라우저들이 HTTP1.1의 단점을 극복하기 위해 여러 개의 Connection을 생성해서 병렬로 요청을 보내기도 한다. 하지만 브라우저 별로 도메인당 Connection 개수 제한이 존재하기 때문에 근복적인 해결은 어렵다.
3. Minified CSS/JavascriptHTTP를 통해 전송되는 데이터의 용량을 줄이기 위해 CSS, Javascript를 축소한다. (ex. name.min.js)
4. Load Fasterhead 태그에 자바스크립트를 삽입하고 async나 defer 옵션을 사용해 브라우저의 파싱을 block 하지 않고 로드한다.
5. Data URI SchemeHTML 문서 내 이미지 리소스를 Base64로 인코딩된 이미지 데이터로 직접 기술하는 방법으로, 서버로의 요청을 줄인다.
6. 구글의 SPDY위에서 언급된 노력들로는 근본적인 단점을 해결할 수 없었다. 그래서 구글은 더 빠른 웹을 실행하기 위해 Throughtput 관점이 아닌 Latency 관점에서 HTTP를 고속화한 SPDY(스피티)라 불리는 새로운 프로토콜을 구현했다.다만 SPDY는 HTTP를 대체하는 프로토콜이 아니고 HTTP를 통한 전송을 재정의하는 형태로 구현되었다. 이는 HTTP2.0 초안의 참고 규격이 된다.

## HTTP 2.0

HTTP2.0은 HTTP1.1을 완전하게 재작성한 것이 아니라 프로토콜의 성능에 초첨을 맞춰 수정한 버전이라고 생각하면 된다. 특히 End-user가 느끼는 Latency나 네트워크, 서버 리소스 사용량 등과 같은 성능 위주로 개선되었다.

### 주요 특징

- Multiplexed Streams: connection 한 개로 동시에 여러 개의 메시지를 주고 받을 수 있으며, 응답은 순서에 상관없이 stream으로 주고 받는다.
- Stream Prioritization: 리소스 간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결함ex. 문서 내에 CSS파일 1개와 이미지 파일 2개가 존재하고 이를 클라리언트가 요청하는 상황에서 이미지 파일보다 CSS 파일의 수신이 늦어진다면 렌더링에 문제가 생기게 되는데 이를 해결함.Server Push클라이언트가 요청하지 않은 리소스를 서버가 사전에 푸쉬를 통해 전송할 수 있다.ex. 푸쉬가 가능하면 클라이언트가 추후에 HTML문서를 요청할 때 해당 문서 내의 리소스를 사전에 클라이언트에서 다운로드할 수 있도록 하여 클라이언트의 요청을 최소화할 수 있음
- Header Compression헤더 정보를 HPACK 방식으로 압축한다.



- 위 그림처럼 클라이언트가 요청을 두 번 보낸다고 가정하면, HTTP1.1의 경우 헤더 중복이 발생해도 중복 전송한다. 하지만 2.0의 경우 헤더에 중복이 있는 경우 Static/Dynamic Header Table 개념을 이용하여 중복을 검출해내고, 해당 테이블에서의 index값 + 중복되지 않은 Header 정보를 Huffman Encoding 방식으로 인코딩한 데이터를 전송한다.

## ☑️ **HTTP와 HTTPS**는 무엇이 다른가?

---

### **[ HTTP와 HTTPS]**

HTTP 통신은 클라이언트와 서버간의 통신에 있어서 별다른 보안 조치가 없기 때문에 만약 누군가 네트워크 신호를 가로챈다면 HTTP의 내용은 그대로 외부에 노출된다. 중요 정보가 없는 소규모의 프로젝트라면 문제가 되지 않겠지만 고객의 **개인정보나 비밀**을 취급하는 대규모 서비스라면 큰 보안적 허점이 될 것이다. 이런 문제를 해결하기 위해 등장한 것이 **HTTPS**이다.

HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. 하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다. (물론 오늘날에는 거의 차이를 못느낄 정도이다.) 또한 HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생하다.

### **[ HTTPS란]**

요즘은 거의 모든 사이트의 주소창에서 자물쇠 표시를 볼 수 있다. **HTTPS**가 적용되었다는걸 알려주는게 바로 저 자물쇠 이다. HTTPS가 옛날부터 보편화되어있지는 않았다. 처음에는 **전자상거래** 등 고객의 중요 정보를 다루는 사이트 위주로 사용되었다.

그러다가 2014년 구글에서는 HTTP를 HTTPS로 변환하라고 권고하기 시작했다. 구글은 HTTPS를 적용하는 사이트들에게 **SEO(검색 엔진 최적화)**에 있어서 가산점을 주겠다고 했다. 사용자 정보의 안전성도 보장받고, 사용자들의 웹사이트 유입도 늘릴수 있으니 HTTPS로 변환할 이유는 충분했을 것이다.



### [HTTPS는 어떤 방식으로 보안 이슈를 해결하는가?]

기존의 HTTP 프로토콜은 **전송계층의 TCP**위에서 동작한다. 여기서 **SSL**(Secure Sockets Layer)이라는 보안계층이 전송계층 위에 올라간다. HTTPS는 SSL 위에 HTTP를 얹어서 보안이 보장된 통신을 하는 프로토콜이다. 이 통신 방식을 **SSL 암호화 통신** 이라고도 한다. SSL 암호화 통신은 **공개키 암호화 방식**이라는 알고리즘을 통해 구현된다.



### [공개키 암호화 방식이란?]



공개키 암호화 방식에는 **공개키와 개인키** 두 종류의 키가 존재한다. 한쪽 키로 데이터를 암호화 했다면 오직 다른쪽 키로만 복호화를 할 수 있다.



### [클라이언트와 서버간의 요청과 응답 과정]

CA는 서버 운영 기업이 넘겨준 공개키를 인증서 발급자, CA의 이름 등과 함께 묶어서 CA가 가지고 있는 개인키로 암호화해서 **SSL인증서**로 발급해준다.

차후에 클라이언트에서 요청을 하면 서버는 클라이언트에게 SSL 인증서를 보낸다. 브라우저(클라이언트)는 대표적인 CA들의 리스트와 그들의 공개키를 보유하고 있다. 만약 인증서에 적힌 CA의 이름과 브라우저가 소유하고 있는 CA 이름이 같다면 CA의 공개키로 SSL 인증서를 복호화 한다.

이제 SSL내부에 들어있던 서버의 공개키를 가지고 요청을 암호화해서 서버에게 보낸다. 서버측은 가지고 있는 개인키로 요청을 복호화하여 해석하고 응답은 다시 암호화 해서 보낸다. 이 과정을 통해 보안성이 강한 통신을 할 수 있게 된다.

### [그렇다면 언제 HTTP를 쓰고, 언제 HTTPS를 쓰는 것이 좋을까?]

개인 정보와 같은 민감한 데이터를 주고 받아야 한다면 HTTPS를 이용해야 하지만, 노출이 되어도 괜찮은 단순한 정보 조회 등 만을 처리하고 있다면 HTTP를 이용하면 된다.

## ☑️ QUIC / HTTP3란?

---

QUIC은 Quick UDP Internet Connections 의 약자이며, UDP를 기반으로 TCP + TLS + HTTP 의 기능을 모두 구현하는 프로토콜이다.

구글에서 개발했던 SPDY 기술이 HTTP/2의 기반 기술이었는데 역시 구글에서 개발한 QUIC이 HTTP/3의 기반 기술이 되었다.


## HTTP/3

HTTP/3는 HTTP(Hypertext Transfer Protocol)의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 **`UDP`** 기반의 프로토콜인 **`QUIC`** 을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.UDP를 사용하지만 **그렇다고 기존의 신뢰성 있는 통신이라는 타이틀을 포기한 것은 아니다.**

구글이 QUIC을 만들 때 UDP를 선택한 이유에는 기존의 TCP를 수정하기가 어려운데다가, 백지 상태나 다름 없는 UDP를 사용함으로써 QUIC의 기능을 확장하기 쉬웠기 때문이라고 한다.

- **RTT 감소로인한 지연시간 단축**
    - QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3 Way Handshake 과정을 거치지 않아도 된다. 클라이언트가 보낸 요청을 서버가 처리한 후 다시 클라이언트로 응답해주는 사이클을 RTT(Round Trip Time)이라고 하는데, TCP는 연결을 생성하기 위해 기본적으로 1 RTT가 필요하고, 여기에 TLS를 사용한 암호화까지 하려고 한다면 TLS의 자체 핸드쉐이크까지 더해져 총 3 RTT가 필요하다.
    
 
    - 반면 QUIC은 첫 연결 설정에 1 RTT만 소요된다. 그 이유는 **연결 설정에 필요한 정보와 함께 데이터도 보내버리기 때문**이다. 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다는 것이다.
    - 단, 클라이언트가 서버로 첫 요청을 보낼 때는 서버의 세션 키를 모르는 상태이기 때문에 목적지인 서버의 Connection ID를 사용하여 생성한 특별한 키인 초기화 키(Initial Key)를 사용하여 통신을 암호화 한다.그리고 한번 연결에 성공했다면 서버는 그 설정을 캐싱해놓고 있다가, 다음 연결 때는 캐싱해놓은 설정을 사용하여 바로 연결을 성립시키기 때문에 **0 RTT**만으로 바로 통신을 시작할 수도 있다. 이런 점들 때문에 QUIC은 기존의 TCP+TLS 방식에 비해 지연시간을 더 줄일 수 있었던 것이다.
    - TCP Fast Open + TLS 1.3 으로 구현이 되긴하지만 주고 받는 데이터가 큰 경우 QUIC가 유리하다.
- **패킷 손실 감지에 걸리는 시간 단축**
    - QUIC도 TCP와 마찬가지로 전송하는 패킷에 대한 흐름 제어를 해야한다. 통신과정에서 발생한 에러를 재전송을 통해 에러를 복구하는 ARQ 방식을 사용하기 때문이다.
    - TCP는 여러 ARQ 방식 중에서 Stop and Wait ARQ 방식을 사용하고 있다. 이 방식은 송신 측이 패킷을 보낸 후 타이머를 사용하여 시간을 재고, 일정 시간이 경과해도 수신 측이 적절한 답변을 주지 않는다면 패킷이 손실된 것으로 판단하고 해당 패킷을 다시 보내는 방식이다.
    - TCP에서 패킷 손실 감지에 대한 대표적인 문제는 송신 측이 패킷을 수신측으로 보내고 난 후 얼마나 기다려줄 것인가, 즉 타임 아웃을 언제 낼 것인가를 동적으로 계산해야한다는 것이다. 이때 이 시간을 RTO(Retransmission Time Out)라고 하는데, 이때 필요한 데이터가 바로 RTT(Round Trip Time)들의 샘플들이다.
    - 한번 패킷을 보낸 후 잘 받았다는 응답을 받을 때 걸렸던 시간들을 측정해서 동적으로 타임 아웃을 정하는 것이다. 즉, RTT 샘플을 측정하기 위해서는 반드시 송신 측으로 부터 ACK를 받아야하는데, 정상적인 상황에서는 딱히 문제가 없으나 타임 아웃이 발생해서 패킷 손실이 발생하게 되면 RTT 계산이 애매해진다.이런 경우를 위해 QUIC는 헤더에 별도의 패킷 번호 공간을 부여해 패킷 고유의 번호를 가지고 있는다.
    - TCP의 경우 타임스탬프를 사용할 수 있는 상황이라면 타임스탬프를 통해 패킷의 전송 순서를 파악할 수 있지만, 만약 사용할 수 없는 경우 시퀀스 번호에 기반하여 암묵적으로 전송 순서를 추론할 수 밖에 없다.QUIC는 이런 불필요한 과정을 패킷마다 고유한 패킷 번호를 통해 해결함으로써 패킷 손실 감지에 걸리는 시간을 단축할 수 있었다. (이 외의 다른 기법들도 이용한다.)
- **멀티플렉싱을 지원**
    - HTTP/3도 HTTP/2와 같은 멀티플렉싱을 지원한다.QUIC 또한 HTTP/2와 동일하게 멀티플렉싱을 지원하기 때문에, 이런 이점을 그대로 가져가고 있다.하나의 스트림에서 문제가 발생한다고 해도 다른 스트림은 지킬 수 있게 되어 이런 문제에서 자유로울 수 있다.
- **클라이언트의 IP가 바뀌어도 연결이 유지됨**
    - TCP의 경우 소스의 IP 주소와 포트, 연결 대상의 IP 주소와 포트로 연결을 식별하기 때문에 클라이언트의 IP가 바뀌는 상황이 발생하면 연결이 끊어져 버린다. 연결이 끊어졌으니 다시 연결을 생성하기 위해 결국 Handshake 과정을 다시 거쳐야한다는 것이고, 이 과정에서 다시 레이턴시가 발생한다.(모바일의 경우 Wi-fi , 셀룰러 전환으로 인해 ip 변경이 잦음)
    - 반면 QUIC은 Connection ID를 사용하여 서버와 연결을 생성한다. Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다. 이는 새로 연결을 생성할 때 거쳐야하는 핸드쉐이크 과정을 생략할 수 있다는 의미이다.
