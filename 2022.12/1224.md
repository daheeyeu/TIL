- Stateful 과 Stateless는, 클라이언트와 서버간의 네트워크 통신이 어떻게 이루어지는지에 대한 개념. 즉, 네트워크 프로토콜이다.

## 1. 세션 상태 및 세션 정보

1. 세션 상태
    - 클라이언트와 서버간 통신 인증이 된 상태 의미.
    - 인증된 상태에서 데이터 송수신이 가능하다.
2. 세션 정보한 세션 내에서, 클라이언트가 서버에 전송할 데이터 정보
    - 서버는 세션 유지 시간이 지나거나, 클라이언트가 전송하려했던 데이터를 모두 수신할 때 까지 클라이언트와의 세션 상태를 유지한다.

## 2. Stateful

- 세션이 종료될 때까지, 클라이언트의 세션 정보를 저장하는 네트워크 프로토콜.ex) TCP 프로토콜, 온라인뱅킹
- 장점: 서버는 클라이언트의 세션 정보를 저장하므로, 갑자기 통신이 중단되더라도 중단된 곳 부터 시작할 수 있다.
- 단점: 확장성이 좋지 않다(클라이언트의 세션 정보가 새로 scale out된 서버에 저장 되어 있지 않다.-> scale out시, 클라이언트의 세션 정보를 새로운 서버에 옮겨주는 등의 부수적인 관리가 요구기 때문)
    
    > **scale out**
    인프라 확장(서버를 운영하는 중 이용자 증가, 사업 확장 등의 이유를 많은 서버 용량과 성능을 필요로 하게되므로) 을 위한 방법 중 한가지.서버를 여러대 추가하여 시스템을 확장하는 것 -> 서버가 여러대로 나뉘기 때문에 서버에 걸리는 부하를 균등하게 '로드밸런싱'을 동반한다.여러 대의 서버로 나눠 시스템을 확장하기 때문에 수평 스케일로 불린다.
    **+ scale up** : 기존 서버의 사양을 업그레이드해 시스템을 확장. CPU나 RAM등을 추가, 교체하는 방법으로 하나의 서버 사양을 업그레이드 하기 때문에 수직 스케일로 불린다.
    > 

## 3. Stateless

- 서버가 클라이언트의 세션 상태 및 세션 정보를 저장하지 않는 네트워크 프로토콜. 즉, 요청에 대한 응답만 처리하는 방식(각 통신은 선행, 후속으로 따라오는 통신과 관련) -> 클라이언트가 송신하려 했던 모든 데이터가 서버쪽에 수신되었는지 확인하지 않습니다.ex) UDP 프로토콜, 온라인 검색
- 장점: 확장성이 좋다. (서버가 클라이언트의 세션 상태 및 세션 정보를 저장하지 않기 때문에)
- 단점: 서버가 세션 상태 및 세션 정보를 저장하지 않기 때문에, 클라이언트 측에서 송신할 데이터의 양이 많아진다.

### HTTP 는 Stateless 한데 로그인은 어떻게 구현할 수 있을까? 로그인 처럼 인증상태를 유지 해야 하는 경우에는 어떻게 하지?

비연결적인 특성으로 연결이 해제됨과 동시에 서버와 클라이언트는 클라이언트가 이전에 요청한 결과에 대해서 잊어버리게 된다. 즉, 클라이언트가 이전 요청과 같은 데이터를 원한다고 하더라도 다시 서버에 연결을 하여 동일한 요청을 시도해야만 한다.

HTTP는 이러한 특성으로 인해 'Stateless Protocol' 이라고 불리며, 독립적인 쌍의 요청과 응답을 처리함으로 단순하고, 상태를 저장해야 하는 서버의 부담을 감소시킬 수 있다.

HTTP가 비연결성과 무상태 라는 강력한 특성을 갖는 건 알겠는데 상태가 서버에 저장되어 있지 않는다면 '인증'은 어떻게 구현해야 할까? 매번 클라이언트는 데이터베이스를 왕복하며 인증을 해야 하는 걸까?

🤔 **서로의 연결성과 상태 유지하지 않는 서버와 클라이언트가 로그인을 처리하려면 어떻게 해야할까?**

> 로그인은 인증(Authentication) 의 한 방법이다. 서비스를 사용하는 사람이 본인이 맞는지 확인하는 것을 인증이라고 한다. 로그인 상태를 유지한다는 것은 인증상태를 유지한다는 것이다.
> 

위 정의에도 명시되어 있듯이 로그인은 인증을 하고 일정 시간동안 인증상태를 유지해야만 한다. HTTP 를 사용하는 입장에서 굉장히 난감한 상황이다.

하지만 이를 해결하기 위한 방법 역시 존재한다. 바로 쿠키와 세션을 사용하는 것이다. 

### 쿠키(Cookie)

쿠키는 웹 브라우저가 보관하는 데이터입니다. 웹 서버는 쿠키를 생성하여 웹 브라우저에 정보를 전송할 수 있다. 쿠키는 키-밸류 형태로 웹 브라우저의 쿠키 저장소에 저장된다. 서버로부터 쿠키를 전달받은 웹 브라우저는 이후 웹 서버에 요청을 보낼 때 쿠키를 헤더에 실어서 함께 전송한다. 이를 이용하면 웹 서버와 클라이언트는 필요한 값을 공유하고 상태를 유지할 수 있다.


클라이언트에 보관된 쿠키는 유효기간 설정이 가능하다. 유효기간을 설정하면 쿠키는 특정 시간이 지나면 자동으로 소멸한다. 유효기간을 설정하지 않을 시에는 브라우저 종료와 함께 소멸한다.

하지만 쿠키만으로 로그인을 구현하는 것은 한계가 있다. 쿠키는 네트워크를 통해 전달되기 때문에 중간에 쿠키를 탈취할 수 있다는 취약점이 있다. 이를 보완하고자 우리는 세션(Session) 을 사용한다.

### 세션(Session)

세션도 마찬가지로 클라이언트의 상태를 저장할 수 있다. 쿠키와 다른 점은 쿠키는 각 브라우저의 별도 쿠키 저장소에 저장되는 반면에 세션은 서버에 저장이 된다.

웹 브라우저는 각각 별도의 세션을 갖는다. 각 세션을 구분하기 위해 고유 ID 를 할당하고, 웹 서버는 각 브라우저에 세션 ID 를 전송한다. 웹 브라우저는 웹 서버에 연결 시 매번 세션 ID 를 보내서 웹 서버가 어떤 세션을 사용할 지 알 수 있도록 한다. 이 때, 웹 서버와 웹 브라우저가 세션 ID 를 주고받기 위해서 사용하는 것이 쿠키다. (Tomcat 에서 발급하는 쿠키의 Key 는 JSESSIONID 이다.)

아래 그림을 보면 클라이언트와 웹서버가 세션과 쿠키를 이용하여 어떻게 로그인 인증 절차를 가지는지 확인할 수 있다.



이를 종합하여 로그인이 이루어지는 과정을 살펴보자. 우리는 로그인 정보를 웹 컨테이너 메모리의 세션 객체에 저장하게 되고, 클라이언트는 세션 ID를 전송하여 브라우저 고유 세션을 식별하게 된다. 이 후 세션 객체 내부에 로그인 여부를 확인할 수 있는 특정 속성이 존재하면 로그인한 것으로 판단할 수 있다.

## 정리

1. HTTP 는 '비연결성'과 '무상태' 라는 특성을 지님으로 멀티 쓰레드 환경에서 웹 어플리케이션이 보다 많은 요청과 응답을 할 수 있도록 한다.

2. 하지만 웹 어플리케이션은 상태를 유지해야 하는 서비스가 존재한다. 이에 대표적인 서비스가 '로그인' 이다.

3. '세션' 과 '쿠키' 를 사용하면 HTTP 의 특성의 한계를 극복하고 보다 쉽게 로그인을 구현할 수 있다.
