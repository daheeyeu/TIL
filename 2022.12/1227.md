**GRASP Pattern이란?**

**책임할당에 기반한 객체 설계 원칙**
해당 내용은 상호작용하는 클래스 혹은 객체에 책임을 할당하는데 도움이 되는 개념과 방법 즉 패턴들로 이루어져 있다. 이러한 내용들을 준수함으로써 좋은 객체지향 디자인 패턴을 만들어낼 수 있다.

- General Responsibility Assignment Software Patterns
- Object-Oriented 디자인의 핵심은 각 객체에 책임을 부여하는 것.
- 책임을 부여하는 원칙들을 말하고 있는 패턴.
- 구체적인 구조는 없지만, 철학을 배울 수 있다.
- 총 9가지의 원칙을 가지고 있다.
- **기본 5가지 패턴들**

1) Creator

2) Information Expert

3) Low Coupling

4) High Cohesion

5) Controller

- **4가지 추가 패턴들**

6) Polymorphism

7) Pure Fabrication

8) Indirection

9) Protected Variations

1. **Information Expert:** 역할을 수행할 수 있는 정보를 가지고 있는 객체에 역할을 부여하자. 단순해 보이는 이 원칙은 객체지향의 기본 원리 중에 하나이다. 객체는 데이터와 처리로직이 함께 묶여 있는 것이고, 자신의 데이터를 감추고자 하면 오직 자기 자신의 처리 로직에서만 데이터를 처리하고, 외부에는 그 기능(역할)만을 제공해야 하기 때문이다.
    
    상황 : 객체에 책임을 할당하기 위한 일반적인 원리는 무엇인가?
    
    해법 : 책임을 수행하기 위해 필요한 정보를 가장 많이 갖고 있는 객체에게 그 책임을 할당한다.
    
2. **Creator:** 객체의 생성은 생성되는 객체의 컨텍스트를 알고 있는 다른 객체가 있다면, 컨텍스트를 알고 있는 객체에 부여하자. A 객체와 B 객체의 관계의 관계가 다음 중 하나라면 A의 생성을 B의 역할로 부여하라.B 객체가 A 객체를 포함하고 있다.B 객체가 A 객체의 정보를 기록하고 있다.A 객체가 B 객체의 일부이다.B 객체가 A 객체를 긴밀하게 사용하고 있다.B 객체가 A 객체의 생성에 필요한 정보를 가지고 있다.
    
    상황 : 어떤 클래스의 새로운 인스턴스를 생성하는 책임(Responsibility)을 누가 가져야 할까?
    
    해법 : 다음과 같은 상황일 때 클래스 B에게 A 클래스의 인스턴스를 생성하는 책임을 부여한다.
    
    1. B가 A를 포함할 때
    2. B가 A 인스턴스를 기록할 때
    3. B가 A를 많이 사용할 때
    4. B가 A 객체를 초기화하기 위한 데이터를 갖고 있을 때
    
3. **Controller:** 시스템 이벤트(사용자의 요청)를 처리할 객체를 만들자. 시스템, 서브시스템으로 들어오는 외부 요청을 처리하는 객체를 만들어 사용하라. 만약 어떤 서브시스템안에 있는 각 객체의 기능을 사용할 때, 직접적으로 각 객체에 접근하게 된다면 서브시스템과 외부간의 Coupling이 증가되고, 서브시스템의 어떤 객체를 수정할 경우, 외부에 주는 충격이 크게 된다. 서브시스템을 사용하는 입장에서 보면, 이 Controller 객체만 알고 있으면 되므로 사용하기 쉽다.
    
    상황 : UI계층에서 사용자의 입력을 받아 처리하는 것은 누구의 책임인가?
    
    해법 : 컨트롤러를 만들어서, 컨트롤러가 사용자의 요청을 받아 로직을 분기해서 처리한다.
    
4. **Low Coupling:** 객체들간, 서브 시스템들간의 상호의존도가 낮게 역할을 부여하자. Object-Oriented 시스템은 각 객체들과 그들 간의 상호작용을 통하여 요구사항을 충족시키는 것을 기본으로 한다. 그러므로, 각 객체들 사이에 Coupling이 존재하지 않을 수는 없다. 이 패턴은 요구사항은 충족시키면서도 각 객체들, 각 서브시스템 간의 Coupling를 낮은 수준으로 유지하는 방향으로 디자인하라고 말하고 있다. Low Coupling은 각 객체, 서브시스템의 재 사용성을 높이고, 시스템 관리에 편하게 한다.
    
    상황 : 클래스 간의 낮은 의존도, 변경에 유연함, 재사용성을 높히려면 어떻게 할까?
    
    해법 : 커플링이 적게(Low Coupling) 책임을 할당한다.
    
    - 커플링의 종류
    
    1) X가 Y 인스턴스를 참조하는 변수를 갖고 있을 때
    
    2) X가 Y 객체의 서비스를 요청할 때
    
    3) X가 Y의 직접,간접적 서브 클래스일 때
    
    4) X가 Y 인터페이스를 구현했을 때
    
5. **High Cohesion:** 각 객체가 밀접하게 연관된 역할들만 가지도록 역할을 부여하자. 이 패턴은 Low Coupling 패턴과 동전의 양면을 이루는 것으로, 한 객체, 한 서브시스템이 자기 자신이 부여받은 역할만을 수행하도록 짜임새 있게 구성되어 있다면, 자신이 부여 받은 역할을 충족시키기 위해 다른 객체나 시스템을 참조하는 일이 적을 것이고, 그것이 곧 Low Coupling이기 때문이다.
    
    상황 : 너무 복잡하지 않게하기 위해 관리를 하려면 어떻게 할까?
    
    해법 : 결합도가 높도록 책임을 할당하라
    
    - Low Coupling이 만족되면 High Cohesion도 만족된다.
    이것과 관련된 원칙은 **SOLID의 Single responsibility principle**가 있다. 이 원칙은 객체를 변경할 수 있는 책임이 하나만 존재해야 한다는 원칙이다.
6. **Polymorphism:** 객체의 종류에 따라 행동양식이 바뀐다면, Polymorphism 기능을 사용하자. Object-Oriented 시스템은 상속과 Polymorphism(다형성)을 지원한다. 만약 객체의 종류에 따라 행동이 바뀐다면 객체의 종류를 체크하는 조건문을 사용하지 말고, Object-Oriented 시스템의 Polymorphism 기능을 사용하라.
    
    상황 : 대체 가능한 소프트웨어 구성요소들을 어떻게 생산하는가?
    
    해법 : 다형성을 이용해서 코딩하라.
    
7. **Pure Fabrication:** Information Expert 패턴을 적용하면 Low Coupling과 High Cohesion의 원칙이 깨어진다면, 기능적인 역할을 별도로 한 곳으로 모으자. 데이터베이스 정보를 저장하거나, 로그 정보를 기록하는 역할에 대해 생각해 보자. 각 정보는 각각의 객체들이 가지고 있을 것이다. 이 때 Information Expert 패턴을 적용하면, 각 객체들이 정보를 저장하고, 로그를 기록하는 역할을 담당해야 하지만, 실제로 그렇게 사용하는 사람들은 없다. 이것은 그 기능들이 시스템 전반적으로 사용되고 있기 때문에 각 객체에 그 기능을 부여하는 것은 각 객체들이 특정 데이터베이스에 종속을 가져오거나, 로그을 기록하는 매커니즘을 수정할 경우, 모든 객체를 수정해야 하는 결과를 가져온다. 즉 Low Coupling의 원칙이 깨어지게 된다. 이럴 경우에는 공통적인 기능을 제공하는 역할을 한 곳으로 모아서 가상의 객체, 서브시스템을 만들어라.
    
    상황 : Information Expert에 근거하여, 정보가 많은 객체에 책임을 부여했는데
    
    High Cohesion, Low Coupling이 위반될 때 어떻게 하는가?
    
    해법 : 인위적으로 어떤 클래스를 만들어서,
    
    문제가되는 책임만 모아 High Cohesion을 갖는 클래스가 되도록 만든다.
    
    Ex. Database 관련된 작업을 하는 DAO(Data Access Object) 객체를 Pure Fabrication으로 볼 수 있다. 만약 유저 정보를 DB에 삽입하려하면, Information Expert에 따르면 유저정보를 갖고있는 유저 객체가 DB에 접근하는 것이 맞지만, 이는 Low Coupling, High Cohesion을 위반한다. 왜냐하면, DB에 접근하는 책임이 여러 곳에 분산되기 때문이다. 따라서 DAO라는 인위적인 객체를 만들고, DB에 접근하는 책임을 할당한다.
    
8. **Indirection:** 두 객체 사이의 직접적인 Coupling을 피하고 싶으면, 그 사이에 다른 객체를 사용하라. 여기서 말하는 다른 객체란 인터페이스가 될 수 있고, 주로 인터페이스인 경우가 많다. 그런 특별한 경우는 아래에 설명된 Protected Variations 패턴이라고 부를 수 있다.
    
    상황 : 두 개의 객체 간의 직접적인 커플링을 피하기 위한 책임을 어디에 할당하는가?
    
    Low Coupling, High Cohesion이 만족하도록 커플링을 피하려면 어떻게 하는가?
    
    해법 : 두 객체 사이에 중간 객체를 만든다.
    
    Ex. Adapter
    
    사용하는 객체 - Adapter - Adapter 구현 클래스
    
9. **Protected Variations:** 변경될 여지가 있는 곳에 안정된 인터페이스를 정의해서 사용하자. JDBC에 대해서 생각해 보자. JDBC는 일련의 인터페이스들로 구성되어 있으며, 각 데이터베이스 벤더들이 인터페이스를 구현한 Concrete 클래스를 제공하고 있다. 데이터베이스 기능을 사용하는 시스템의 입장에선 각 벤더들이 구현방식을 바꾸었을 때, 자신의 코드를 수정하고 싶지 않을 것이다. 그래서 Driver를 로딩하는 코드를 제외하고는 모두 인터페이스를 사용함으로서 데이터베이스의 변경시에도 Driver 로딩만 바꾸어 주면 되도록 데이터베이스 관련 작업이 필요한 곳에는 안정된 JDBC 인터페이스를 사용한 것이다.
    
    상황 : 한 요소에서의 변화나 확장이 다른 요소들에게 영향을 미치지 않도록 하려면 어떻게 하는가?
    
    해법 : 변화가 다른 곳으로 전이되는 곳에 인터페이스를 이용해서 감싸라
