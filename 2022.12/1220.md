## 1.****디자인 패턴(Design Pattern)이란?****

디자인 패턴은 설계자로 하여금 재사용이 가능한 설계는 선택하고, 재사용을 방해하는 설계는 배제하도록 도와줍니다. 또한 패턴을 쓰면 이미 만든 시스템의 유지보수나 문서화도 개선할 수 있고, 클래스의 명세도 정확하게 할 수 있으며, 객체 간의 상호작용 또는 설계 의도까지 명확하게 정의할 수 있습니다.

간단하게 말해서 **디자인 패턴**은 설계자들이 **"올바른"** 설계를 **"빨리"** 만들 수 있도록 도와줍니다.

디자인 패턴(Design Pattern)은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴입니다. 디자인 패턴 계의 교과서로 불리는 **[GoF의 디자인패턴]**에서는 객체지향적 디자인 패턴의 카테고리를 **"생성 패턴(Creational Pattern)"**, **"구조 패턴(Structural Pattern)"**, **"행동 패턴(Behavioral Pattern)"** 3가지로 구분하고 있습니다.

### **디자인 패턴 요약**

🚩 **생성**

1) `Builder` : 생산 단계를 캡슐화 하여 구축 공정을 동일하게 이용하도록 하는 패턴
2) `Prototype` : 복사하여 새 개체를 생성할 수 있도록 하는 패턴
3) `Factory Method` : 객체를 생성하기 위한 인터페이스를 정의하여 어떤 클래스가 인스턴스화 될 것인지는 서브 클래스가 결정하도록 하는 패턴
4) `Abstract Method` : 생성군들을 하나의 모아놓고 팩토리 중에서 선택하게 하는 패턴
5) `Singleton` : 유일한 하나의 인스턴스를 보장하도록 하는 패턴

🚩 **구조**
1) `Bridge` : 추상과 구현을 분리하여 결합도를 낮춘 패턴
2) `Decorator` : 소스를 변경하지 않고 기능을 확장하도록 하는 패턴
3) `Facade` : 하나의 인터페이스를 통해 느슨한 결합을 제공하는 패턴
4) `Flyweight` : 대량의 작은 객체들을 공유하는 패턴
5) `Proxy` : 대리인이 대신 그 일을 처리하는 패턴
6) `Composite` : 개별 객체와 복합 객체를 클라이언트에서 동일하게 사용하도록 하는 패턴
7) `Adapter` : 인터페이스로 인해 함께 사용하지 못하는 클래스를 함께 사용하도록 하는 패턴

🚩 **행위**
1) `Interpreter` : 언어 규칙 클래스를 이용하는 패턴
2) `Template Method` : 알고리즘 골격의 구조를 정의한 패턴
3) `Chain of Responsibility` : 객체들끼리 연결 고리를 만들어 내부적으로 전달하는 패턴
4) `Command` : 요청 자체를 캡슐화하여 파라미터로 넘기는 패턴
5) `Iterator` : 내부 표현은 보여주지 않고 순회하는 패턴
6) `Mediator` : 객체 간 상호작용을 캡슐화한 패턴
7) `Memento` : 상태 값을 미리 저장해 두었다가 복구하는 패턴
8) `Observer` : 상태가 변할 때 의존자들에게 알리고, 자동 업데이트하는 패턴
9) `State` : 객체 내부 상태에 따라서 행위를 변경하는 패턴
10) `Strategy` : 다양한 알고리즘 캡슐화하여 알고리즘 대체가 가능하도록 한 패턴
11) `Visitor` : 오퍼레이션을 별도의 클래스에 새롭게 정의한 패턴

### **디자인 패턴에서 생각해야 할 요소들**

1. **패턴 이름(Pattern Name)** - 패턴의 이름은 해당 패턴의 솔루션을 담고 있는 경우가 많습니다. 따라서 설계에 대한 생각을 더욱 쉽게 할 수 있고, 개발자들 간의 의사소통이 원활해집니다.
2. **문제(Problem)** - 언제 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 뜻합니다. 문제를 제시함으로써 패턴을 적용하는 것이 의미 있는 사례를 소개하겠습니다.
3. **해법(Solution) 및 구현(Implementation)** - 앞서 2번에서 다룬 문제(Problem)에 대하여 어떻게 해결할 수 있을 것인가에 대해 해결책을 제시하고, Java를 통해 예제 코드를 다루겠습니다.
4. **결과(Consequence)** - 디자인 패턴을 적용해서 얻는 결과와 장단점을 서술합니다.

### ****디자인 패턴 공부하는 법****

- 생성(Creational), 구조(Structural), 행동(Behavioral) 패턴이 각각 어떤 문제들을 해결하는지 파악합니다.
- 패턴들 간의 관련성을 파악합니다.
- 비슷한 목적의 패턴들을 모아서 함께 공부합니다.예를 들어, 추상 팩토리 패턴을 공부했다면 이어서 팩토리 메소드 패턴을 학습해보고 각각 어떤 공통점과 차이점이 있는지 비교하여 헷갈리지 않게 정리해둡니다.
- 디자인 패턴이 익숙치 않은 초보 분들은 패턴을 공부할 때에는 반드시 예제 코드를 직접 작성해봅니다.
눈으로만 공부하는 것은 뒤돌아서면 까먹습니다. 다소 귀찮더라도 프로젝트에 적용한다는 생각으로 예제를 확실하게 이해하는 것이 중장기적으로 무조건 이롭습니다.

## 2. Proxy Pattern

> 프록시 패턴은 구조 패턴(Structural Pattern) 중 하나로, 제어 흐름을 조정하기 위한 목적으로 중간에 대리자(proxy)를 두는 패턴입니다. 즉,어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자(surrogate)나 자리표시자(placeholder)의 역할을 하는 객체를 제공하는 패턴입니다.
> 
- **구조 패턴(Structural Pattern)이란?**
- 구조 패턴이란 작은 클래스들을 상속과 합성을 이용하여 더 큰 클래스를 생성하는 방법을 제공하는 패턴입니다.
- 이 패턴을 사용하면 서로 독립적으로 개발한 클래스 라이브러리를 마치 하나인 양 사용할 수 있습니다. 또, 여러 인터페이스를 합성(Composite)하여 서로 다른 인터페이스들의 통일된 추상을 제공합니다.
- 구조 패턴의 중요한 포인트는 인터페이스나 구현을 복합하는 것이 아니라 객체를 합성하는 방법을 제공한다는 것입니다. 이는 **컴파일 단계에서가 아닌 런타임 단계에서 복합 방법이나 대상을 변경할 수 있다는 점에서 유연성을 갖습니다.**

프록시 패턴은 개방 폐쇄 원칙(OCP)과 의존 역전 원칙(DIP)이 적용된 설계 패턴이다.

> 객체에 접근을 제어하고 싶을 때, 다른 객체가 위임해서 대리로 해결하는 방식
1) 객체를 실제 사용하기 전까지 초기화를 미루고 싶을 때 (Lazy init)
2) 접근 권한 통제
> 

스프링의 AOP에서는 이 `프록시` 패턴을 사용한다.`객체를 실제로 부르는 게 아닌, 프록시 객체를 부르고 나중에 프록시 객체가 실제 객체를 호출하는 것이다.`

그렇다면 프록시 패턴으로 실제 객체의 메소드 사용 이전에 로직을 추가해 메소드의 사용 권한을 제한할 수도 있을것이고. 메소드 사용 이후에 별도의 후처리 로직을 추가할 수도 있을 것이다. 또한 실제 객체의 생성을 지연시켜 메모리의 낭비를 줄일 수 있는 역할을 할 수도 있을 것이다.

### 프록시 패턴의 장단점

**프록시패턴 장점**

- 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조를 할 수 있다.
- 실제 객체의 public, protected 메소드를 숨기고 인터페이스를 통해 노출시킬 수 있다.
- 로컬에 있지 않고 떨어져있는 객체를 사용할 수 있다.
- 원래 객체에 접근에 대해 사전처리를 할 수 있다.

**프록시패턴 단점**

- 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능이 저하될 수 있다.
- 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능이 저하될 수 있다.
- 로직이 난해해져 가독성이 떨어질 수 있다.

### 프록시 패턴의 종류

**가상프록시**
꼭 필요로 하는 시점까지 객체의 생성을 연기하고, 해당 객체가 생성된 것 처럼 동작하도록 만들고 싶을 때 사용하는 패턴이다. 프록시 클래스에서 작은 단위의 작업을 처리하고 리소스가 많이 요구되는 작업들이 필요할 경우만 주체 클래스를 사용하도록 구현한다.

**원격프록시**
원격 객체에 대한 접근을 제어 로컬 환경에 존재하며, 원격 객체에 대한 대변자 역할을 하는 객체 서로 다른 주소 공간에 있는 객체에 대해 마치 같은 주소 공간에 있는 것 처럼 동작하게 하는 패턴이다.(예: Google Docs)

**보호프록시**
주체 클래스에 대한 접근을 제어하기 위한 경우에 객체에 대한 접근 권한을 제어하거나 객체마다 접근 권한을 달리하고 싶을 경우 사용하는 패턴으로 프록시 클래스에서 클라이언트가 주체 클래스에 대한 접근을 허용할지 말지 결정하도록 할 수 있다.
