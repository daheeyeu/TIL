## ☑️ Project 진행시 Gradle 을 사용 할 거라고 했는데 그 이유는?

> Gradle은 자바 및 다른 언어를 사용하는 애플리케이션의 빌드 도구로 유명하다. Gradle은 다른 빌드 도구와 비교해 높은 자동화 수준을 제공하고, 다른 언어나 프레임워크와의 통합이 용이하기 때문에 많은 개발자들이 선호한다. 또한 Gradle은 의존성 관리 기능을 포함하고 있어서 프로젝트에 필요한 라이브러리를 쉽게 관리할 수 있기 때문에 프로젝트 진행 시 유용하게 사용될 수 있다.
> 

Gradle은 빌드 도구 중의 하나이다. 빌드 도구란 소프트웨어 개발에 있어 소스 코드를 실행 가능한 어플리케이션으로 만들어주는 도구이다. 빌드 과정을 자동화하여 관리하는 기능을 하기 때문에 Build Management Tool 또는 Build Automation Tool이라고도 한다.

빌드 도구의 특징은 개발자가 스크립트를 작성하여 다양한 작업을 수행할 수 있게 한다. 예를 들어 소스 코드를 컴파일하거나 패키징할 수 있으며, 테스트를 자동으로 수행하거나 의존성 주입 및 배포 작업을 할 수 있다.

- Compile
- Test : 유닛 테스트 또는 전체 테스트
- Packaging : 스프링 코드를 패키징해 jar 또는 war 파일로 만들어 준다.
- Deploy & Run : 만들어진 스프링을 돌려 서버를 실행해준다.

## Gradle

Gradle은 가장 최근에 나온 자바 빌드 도구로 `그루비 (Groovy)` 문법을 사용한다. Build.gradle에 스크립트를 작성하며, 대규모 프로젝트에서 복잡해지는 경향이 있는 XML 기반 스크립트에 비해 관리가 편하다는 장점이 있다. Gradle은 현재 안드로이드 프로젝트의 표준 빌드 시스템으로 채택되어 있다.

## Gradle 장점

- 간결한 스크립트
- 빌드 속도
    - Gradle은 caching을 하기 때문에 Ant나 Maven 같은 이전 빌드 도구보다 빌드 속도가 빠르다.
- 멀티 프로젝트 빌드
    - 대규모 자바 프로젝트는 대부분 다중 모듈로 구성된다.
    - Gradle의 멀티 프로젝트 빌드 기능을 이용하면 번거로움과 실수를 줄일 수 있다.
    - 필요에 따라 개별적으로 설정할 수 있어 스크립트의 작성량이 메이븐보다 적다.
- Wrapper
    - 초기 프로젝트 세팅 시 Gradle Wrapper 사용을 권장한다.
    - 특정 버전의 Java나 Gradle을 설치할 필요없이 바로 프로젝트를 실행할 수 있다.
- 메이븐은 특수한 처리가 필요할 때 독자적인 플러그인으로 구현해야 하지만 gradle은 스크립트를 작성하는 것만으로도 가능하다.

## Maven 보다 Gradle이 나은 이유는?

Gradle과 함께 많이 쓰이고 있다는 Maven의 가장 큰 문제점은 두가지이다.

- 프로젝트 구성/빌드 툴로써 프로젝트 구성은 정적인 설정 정보이고 빌드는 동적인 행위이다. 그런데 이것을 **정적인 데이터를 저장하는데 적합한 XML로 그 내용을 기술하게 함으로써 동적인 행위인 빌드에 크나큰 제약을 가한다**. 게다가 XML은 너무 장황해서 실제 설정 내용보다 XML 뼈대가 더 많다.
- Maven은 설계상의 문제도 있다. 바로 멀티 프로젝트 구성을 **상속 구조**로 한 점이다. 그에 반해 Gradle은 **구성 주입 방식**(Configuration Injection, = 설정 주입 방식)을 사용한다. 이는 빌드 구성 정보에서 매우 큰 차이를 만든다.

즉, **Maven을 사용하면 쓸데없이 설정이 길어지고 중복이 발생하며 가독성도 매우 떨어진다.**

그에 반해 Gradle의 구성주입 방식은 그냥 어떤 프로젝트 구성 정보가 있으면 그것을 필요한 프로젝트에 주입하는 방식이다. 주입시 프로젝트의 조건을 체크할 수 있어서 프로젝트 별로 약간 다른 설정이 가능하다. 또한 공통 구성만 주입하고 프로젝트 별로 다른 점은 바로 그 점만 프로젝트 별로 주입시켜주면 된다.

### **Gradle이 Maven보다 좋은 점.**

**1. Build라는 동적인 요소를 XML로 정의하기(Maven 방식)에는 어려운 부분이 많다.**

- 설정 내용이 길어지고 가독성 떨어짐.
- 의존관계가 복잡한 프로젝트 설정하기에 부적절
- 상속구조를 이용한 멀티 모듈 구현
- 특정 설정을 소수의 모듈에서 공유하기 위해서는 부모 프로젝트를 생성하여 상속하게 해야 함.

**2. Gradle은 Groovy를 사용하기 때문에, 동적인 빌드는 Groovy 스크립트로 플러그인을 호출하거나 직접 코드를 짜면 된다.**

- Configuration Injection 방식을 사용해서 공통 모듈을 상속해서 사용하는 단점을 커버.
- 설정 주입 시 프로젝트의 조건을 체크할 수 있어서 프로젝트별로 주입되는 설정을 다르게 할 수 있다.

이렇게 크게 두가지를 통해 Gradle이 Maven보다 낫다는 걸 알 수 있다.

### 결론

아무리 간편한 툴이라도 그 기능이 요구사항에 못 미치고 버그가 많다면 그걸 사용하면 안된다. 비록 Groovy와 Gradle을 모두 다 배워야 하는 부담이 있겠지만, 그게 장기적으로 더 개발자를 이롭게 할 것이다. 원본 프로젝트의 Java 코드를 직접 호출 할 수 있기 때문에 훨씬 더 편해진다.

Maven에서는 아무리 Java를 알아도 빌드 구성 시 어려운 경우가 많다. 하지만 Gradle을 사용한다면 훨씬 더 편하게 처리할 수 있다.

빌드가 아니라 프로젝트 운영 코드를 짜는데 더 집중하고 싶다면 Gradle을 사용하자.
💡 **+ 참고 Gradle을 사용하면서 느낀 Maven의 문제점 [from_maven](http://wiki.kwonnam.pe.kr/gradle/from_maven)**

## ☑️ Sync 와 Async / blocking 과 Non-blocking

> 자세한 설명은[멀티스레드, 멀티프로세싱, 스레드 키워드](https://www.notion.so/b4e2b5ff0e514337b5d6fe4c8e533d90) 참고!!!!
> 

### Sync / Async

처리해야 할 작업들을 **어떠한 '흐름'**으로 처리 할 것인가에 대한 관점, 즉, 호출되는 **함수의 작업 완료 여부**를 **신경쓰냐**에 따라, 함수 실행/리턴 **순차적인 흐름**을 따르느냐, 안따르느냐 관심사

Sync와 Async는 결과를 돌려주었을 때 순서와 결과에 관심이 있는지 없는지로 판단한다.
## ☑️ Sync 와 Async / blocking 과 Non-blocking이 spring mvc & spring webflux 에서 어떻게 활용 되는가?

### Spring MVC, Spring WebFlux란?

- **Spring MVC**는 자바 기반의 웹 애플리케이션을 개발할 때 사용할 수 있는 프레임워크다. Spring MVC는 Model-View-Controller(MVC) 아키텍처 패턴을 따르며, 이를 통해 애플리케이션을 구성하는 데이터 모델, 사용자 인터페이스, 애플리케이션 로직을 분리하여 개발할 수 있도록 도와준다. 이를 통해 애플리케이션의 개발 및 유지보수가 용이해지며, 코드의 재사용성을 높일 수 있다.

- **Spring WebFlux**는 스프링 프레임워크에서 제공하는 리액티브 프로그래밍 기반의 웹 프레임워크다. Spring WebFlux는 이벤트 루프 및 블록킹 I/O를 사용하지 않고, 대신 Reactor 라이브러리를 사용하여 리액티브 프로그래밍을 지원한다. Spring WebFlux를 사용하면 다중 스레드와 데이터 락을 사용하지 않고도 애플리케이션이 많은 요청을 빠르게 처리할 수 있다. 또한 Spring WebFlux는 Spring MVC와 함께 사용할 수 있으며, 기존의 Spring MVC 애플리케이션을 쉽게 리팩토링할 수 있도록 도와준다.

### Spring MVC

Spring MVC는 동기적으로 동작하는 블로킹 방식이다.

- 사용자 요청마다 스레드를 계속 생성해야하는 문제 → 스레드 풀 생성
- 많은 사용자가 동시 요청을 보내면 요청을 처리하지 못하는 문제(Thread Pool Hell 현상)
- 시스템의 트래픽을 측정해서 thread pool size를 잘 조정해야 한다.

일반적으로 spring framework와 spring boot를 쓰는 방식이다.
**Spring MVC의 핵심은 사용자 요청이 들어올떄마다 스레드를 생성해서 처리한다는 점이다.**

그래서 다수의 사용자 요청이 들어와서 계속 스레드를 생성하는 것이 많은 리소스를 사용하게 된다.
이를 방지하기 위해서 어플리케이션이 실행될 때 스레드를 생성하면서 thread pool을 만들어 두는 것이다.
하지만 이 방식은 요청을 계속 처리하지 못하는 Thread Pool Hell현상이 발생할 수 있다는 한계가 있다.
엄청나게 많은 사용자가 동시에 요청을 보낼 경우 풀사이즈를 초과해서 큐에 계속 요청이 쌓이게 되는 것이다.
결국, Spring MVC의 경우 해당 시스템의 트래픽을 측정해서 **thread pool size를 조정하는 것**이 매우 중요하다.

Spring MVC 방식은 많은 사용자의 요청을 대량으로 받아내는데는 한계가 있는데, 이를 WebFlux가 해결해 줄 수 있다.

### WebFlux

Spring webflux는 비동기적으로 동작하는 논블로킹 방식이다.

- Reactive Programming (반응형 프로그래밍)
- Event loop
- 모든 코드가 non-blocking하게 동작해야만 의미가 있다.

Node.js처럼 이벤트 루프가 돈다. 즉, 리액티브 프로그래밍이 가능해진다.
요청이 발생할 경우 그것에 맞는 핸들러에게 처리를 위임하고, 처리가 완료되면 callback메소드를 통해 응답한다.
비동기적이고 논블로킹 방식으로 동작하기 때문에 성능적으로 효율적이다.
또한 WebFlux는 Kotlin과 함께 사용하는 가볍고 기능적인 웹 프레임워크로 불린다. 
Spring boot2부터 도입된 spring5에서 지원되는 스택중에 하나이다.

하지만 WebFlux가 항상 효율적이라고 볼 순 없다.
요청을 처리하는 파이프라인의 요소들이 모두 논블로킹하게 동작해야만 의미가 있는 것이다.
따라서 어떤 특정한 구간에서 블로킹이 발생하는 구간이 있다면 거기에서 부턴 MVC처럼 요청을 계속 처리하지 못하는 Thread Pool Hell현상이 발생할 수 있다는 것이다.
