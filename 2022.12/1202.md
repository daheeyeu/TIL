## Compile vs Interpreter vs Hybrid

### 빌드과정

컴퓨터가 이해하는 언어를 기계어라고 하는데, 우리가 만든 소스 코드가 컴퓨터 입장에서는 해외판 책이 되는 것이고, 이 책을 기계어(machine code)로 번역하여 컴퓨터에서 이해할 수 있는, 즉 실행 가능한 파일로 만드는 과정을 빌드(Build) 라고 한다.
그러나 외국어로 되어있는 책(소스 코드)을 우리나라 말로 번역(빌드)하여 우리(기계)가 읽을 수 있는 책(실행 파일)으로 만드는 과정은 하나만 있는 것이 아니다.

예를 들어 전문 번역가를 고용한다던지, 구글 번역을 사용한다던지, 파파고를 사용한다던지..이렇듯 컴퓨터의 빌드 과정도 모든 언어가 각기 다른 방식을 사용하고 있다.

빌드 과정은 크게 3가지 방식으로 분류를 할 수 있는데, 일단 이름부터 소개하자면 Compile 방식, Interpreter 방식, Hybrid 방식이 있다. Java는 대표적인 Hybrid 방식이다.
# **Compile Type**

---

우리가 작성한 소스코드를 한꺼번에 번역해서 실행파일로 만들어 준다. 한마디로 통번역한다라고 생각하면 된다.

이렇게 한 번에 번역하는 언어들을 보통 Compile Language 라고 하는데, 대표적으로 C, C++, Go 언어가 있다. 이러한 언어들의 빌드 과정은 대개 아래와 같다.
화살표를 보면 두 개로 나뉘다가 링크 작업에서 하나로 합쳐지는 부분을 살펴보자.

만약 책을 번역 할 때 만약 시리즈로 되어있는 책을 번역한다면 각 단권별로 번역한 다음 하나로 묶어 책으로 발간을 할 것이다.

이렇듯 각 파일 단위로 번역과정을 거친 다음 최종적으로 하나로 묶게 되기 때문이다.

### **[preprocessing (전처리)]**

pre + process= **'사전 처리'**
전처리 과정은 **전처리기(preprocessor)** 에 의해 소스코드에 포함 된 매크로나 지시자 같은 것을 포함시켜준다.

**'소스코드의 중심(main)이 실행되기 전에 사전준비 하는 과정'**

책 번역과정으로 치자면 저자 이름, 책에서 정의하는 표현, 판권, 인용 등 이미 정해져 있는 것들을 먼저 처리하여 이후에 일일이 다시 찾아 쓸 필요 없이 정리해두는 과정과 비슷하다.

### **[compilation (컴파일)]**

compile 이라는 뜻이 '번역하다'라는 뜻이다. 흔히 컴파일을 소스코드를 실행파일로 만드는 것으로 생각할 수도  있는데, 엄연하게는 다르다. 말 그대로 '번역'하는 것일 뿐 번역 된 것만으로는 컴퓨터가 실행 할 수는 없다. (외국어 책을 번역만 해놓고 책으로 묶지 않으면 그 건 책이 아니라 그냥 번역만 한 종이일 뿐이다.)

eclipse, Visual Studio, X Code 같은 통합개발환경(IDE : Integrated Development Environment)들은 대부분 한 번 컴파일(또는 빌드)을 하면 실행파일까지 나와버리기 때문에 사람들이 오해하는 점이다.

컴파일하는 프로그램을 **컴파일러(compiler)**라고 한다.

컴파일러가 컴파일 하면 바로 기계어(Machine Code)로 번역 될 것 같지만, 흔히 중간언어 또는 저수준 언어로 번역된다. 보통은 어셈블리어(Assembly Language)로 번역된다.

**🙋🏻‍♀️ 왜 기계어로 바로 번역하지 않고 저수준 언어(low-level Language)로 번역되는걸까?**
과거에는 0과 1로만 작업을 했어야 하다보니 매우 불편했는데, 예로들어 'A'라는 문자를 표현하려면 1000001 이런식으로 표현 했었다. 이렇다 보니 이런 것들을 **부호화(Symbolic)** 한 것이다. 단순히 부호화만 했기 때문에 기계어(Machine Code)와 1대1 매칭이 된다. 그렇다 하더라도 우리가 사용하는 Java, C 같은 고급언어처럼 사람이 읽기 쉬운 언어가 아닌 난해한 언어인지라 저수준 언어(low-level language)에 속하게 되는 것이다.

저수준 언어의 장점으로는  내부가 어떻게 작동하는지, 즉 하드웨어를 직접적으로 조작하거나 특수 프로세서 명령어에 접근 등을 확인하거나 작업을 할 수가 있다는 것이다. 한마디로 인간이 기계어를 이해하기 위해 고급언어와 기계어 사이에 중간단계인 저수준 언어로 번역하는 것이다. 대표적인 C, C++ 모두 어셈블리어라는 저수준 언어로 번역된다.

### **[assemble (어셈블)]**

앞서 컴파일 단계에서 컴파일러가 고급언어를 저수준 언어로 번역을 해줬으니 이 저수준 언어(어셈블리어)를 최종적으로 기계어로 번역해줘야한다. 이 어셈블리어를 기계어로 번역해주는 프로그램을 **어셈블러(Assembler)**라고 합니다.

이렇게 CPU가 이해할 수 있는 언어로 번역된 파일을 보통 **Object File** 이라고도 하는데, 직역하면 '객체 파일'이라고 하지만, 대부분은 객체라 하지 않고 '목적 파일'이라고 한다.

객체는 *"동작의 주체가 누군지 분류하여 동일성을 갖는 기능들을 하나의 묶음으로 만들어낸 하나의 실체" 이다.*

즉, 자판기라는 객체는 음료를 갖고있고, 일정 값어치의 돈을 받으면 그에 대응하는 음료를 반환해주는 하나의 실체이듯, 어셈블리어에서 기계어로 번역된 Object File은 앞서 설명했듯 여러개의 연관된 파일을 빌드하면 '링크' 단계 전까지는 각 파일별로 번역되기 때문에 그 번역된 파일 하나하나가 실행하는 최종 파일의 일부분으로서의 객체가 된다고 보면 된다. 그래서 Object 라는 단어가 붙게 되는 것이다.

그리고 컴파일 과정을 여기까지 포함하기도 한다. Compile이라는 단어 자체가 번역이라는 의미인데, 프로그래밍에서는 크게 두 가지로 해석할 수 있다.

좁은 의미로는 '소스코드를 저수준 언어로 변환해주는 과정'을 의미한다. 근데 어셈블도 번역하는 단계죠. 즉, 컴파일이라고 볼 수도 있다. 그래서 좀 더 넓은 의미로는 전처리 과정부터 어셈블 과정까지를 컴파일 단계라고 부르기도 한다. (또한 컴파일 언어의 빌드 과정에 어셈블이 없다면, 즉, 어셈블리어 같은 저수준 언어가 아닌 바로 기계어로 번역되는 경우는 어셈블 과정이 생략되고 컴파일 단계만 있다.)

### **[linkig (링크/링킹)]**

컴파일(어셈블 포함) 과정을 통해 각 파일들이 기계어로 번역되었다면 이제 하나로 연결해주어야 한다. 책을 번역할 때도 각 낱장별로 번역된 종이들을 하나로 모아 묶어야 책이듯, 각각의 Object File 은 기계가 이해할 수 있는 번역본일 뿐 실행을 할 수 있는 파일이 아니다.

즉, Object File 들과 필요한 라이브러리들을 연결 시켜주고 최종적으로 하나의 'executable file (실행가능한 파일)'로 만들어준다. 우리가 흔히 어떤 프로그램을 사용할 때 .exe 라는 확장자를 갖는 파일을 실행시키는데, 이 exe가 바로 executablue 의 줄임말이다.

이렇게 4단계의 과정은 포괄적으로 보면 '전처리-컴파일-어셈블' 단계를 하나의 컴파일 단계라고 본다. 즉, 빌드와 컴파일의 차이점이 여기서 나오게 되는데, 컴파일은 번역하는 단계로 소스코드를 목적 파일(Object File)로 만들어주는 과정일 뿐 그 결과물이 실행파일인 것은 아니다. 이 컴파일 단계에 링크 과정이 포함 되어야 즉, 빌드가 비로소 실행가능한 파일이 나오는 전체 과정을 의미하는 것이다.

`컴파일 + 링크 = 빌드`

### **컴파일 언어의 장점**

1. 빌드가 완료된 실행가능한 파일은 실행 속도가 빠르다.

2. 매번 번역할 필요 없이 실행 파일만 실행하면 되기 때문에 전체적인 시간면에서 효율적이다.

### **컴파일 언어의 단점**

1. 프로그램을 수정해야 할 경우 처음부터 빌드과정을 다시 거쳐야하기 때문에 특히나 대규모 프로그램에서는 생산성이 떨어진다.

2. 플랫폼에 매우 의존적이다.

**🙋🏻‍♀️ 플랫폼에 의존적이라는 의미는?**
윈도우 실행파일을 맥OS 에서 실행하지 못하는 상황을 생각하면 된다.

크게 두 가지 원인이 있는데, 먼저 어셈블리어의 경우 CPU 명령어 세트에 1대1로 매칭된다.  즉, CPU에 의존적이라는 것인데 CPU 명령 체계가 거의 비슷하긴 하나 완전히 같지는 않다. 그리고 다음으로는 CPU가 이해할 수 있게 번역하여 최종 실행파일로 만들기 위해 링크라는 작업을 해주는데, 이 과정에서 OS 마다 서로 다른 라이브러리가 있어 링커는 해당 OS에서 요구하는 라이브러리를 연결하게 된다.

이러한 이유 때문에 우리가 프로그램을 내려받을 때 윈도우용, 맥용, 64비트, 32비트 등 이렇게 각 버전에 맞는 프로그램을 까는 이유가 이러한 것 때문이다. (또한 운영체제별로 지원하는 것도 조금씩 다르다.)

# **Interpreted Type**

---

인터프리트 타입은 소스코드를 통번역 하는 것이 아닌 한 명령 단위로 해석하면서 즉시실행하는 방법이다. 통역사를 생각하면 된다.
위 그림에서 컴파일 언어와 인터프리트 언어의 가장 큰 차이점은 목적파일(Object File)을 생성하지 않고 바로(direct) 실행된다는 것이다. 보통 이러한 인터프리터 언어에 가장 대표적인 언어는 자바스크립트(JavaScript), 파이썬(Python)과 루비(Ruby)로 알려져 있다.

(이는 정확히 말하자면 절반은 맞고 절반은 틀리다. 이유는 바로 다음인 하이브리드 언어에서 알 수 있다.)

쉽게 말하면 소스코드의 한 명령 세트마다 기계어(Machine Code)로 번역하면서 바로바로 실행해주는 방식을 인터프리트라고 한다. 그리고 이렇게 번역해주는 프로그램(또는 환경)을 **Interpreter(인터프리터)**라고 한다. 즉, 각 **운영체제에 맞는 해당 언어의 인터프리터만 설치한다면 어느 운영체제에서든 해당 언어를 사용하더라도 동일한 결과를 얻을 수 있다는 것이다.** 한마디로 플랫폼에 독립적이다.
또한 이렇게 컴파일 과정 없이 인터프리터를 통해 바로 결과를 볼 수 있기 때문에 프로그램 수정에 매우 유리하다는 장점이 있다.

**🙋🏻‍♀️ 그럼 실행가능한 파일은 없는 것인가?** 
소스코드 그 자체가 실행가능한 파일이 되는 거라고 이해하면 된다. 다만, 소스코드를 번역해줄 수 있는 인터프리터를 설치해야한다.

### **인터프리트 언어의 장점**

1.  컴파일과정 없이 바로 실행하기 때문에 수정, 디버깅에 유리하다. 즉 개발속도에 유리하다.

2. 각 플랫폼에 지원하는 인터프리터만 있다면 실행 가능하기 때문에 플랫폼에 독립적이다.

### **인터프리트 언어의 단점**

1. 빌드 되어있는 컴파일 언어 프로그램보다 실행시간이 느리다.

2. 코드를 열면 다 보이기 때문에 보안에 좋지는 않다.

반대로 컴파일 언어에 비해 매 번 부분씩 번역해야하기 때문에 실행 속도는 느리다는 단점이 있다. 하지만 이마저도 요즘 하드웨어의 스펙이 워낙 높아져 일반 사람들에게는 컴파일 언어와 인터프리터 언어의 실행 차이를 체감하기 힘들정도라 오히려 개발 속도가 빠른 인터프리트 방식을 혼합하여 적용을 하려는 경향이 근래 많아졌다.

# **Hybrid Type**

---

컴파일 방식과 인터프리트 방식을 혼합한 방법이다. 두가지를 혼합한 이유는 무엇일까? 
컴파일 언어의 단점은 실행 가능한 파일이 플랫폼에 의존적이라는 것이지만 실행 속도가 빠르다. 반대로 인터프리터 언어의 단점은 실행속도는 느리지만, 플랫폼에 독립적이라 어느 플랫폼이든 번역기(인터프리터)만 있으면 실행 가능하다.

이 둘의 단점을 상호 보완하여 만들어 진 것이 바로 하이브리드 방식이다.

흔히 **'바이트 코드 언어(Byte Code Language)'** 라고 하며 가장 대표적인 언어로는 Java(자바)가 있다.

<aside>
🗣 책을 번역하는 과정에 비유한다면, 세계적으로 가장 많이 쓰이는 언어는 영어이다. 영어가 모국어가 아닌 국가라 하더라도 영어를 할 줄 아는 사람들이 많을 것이다. 그래서 프랑스어, 힌두어 등등 다른 국가의 언어로 번역된 것을 1차적으로 영어로 번역을 해둔 다음, 영어로 번역된 것을 한국어로 번역하면 번역 가능한 사람이 많은 만큼 쉽고 빠르게 번역할 수 있을 것이다.

</aside>

위의 비유처럼 영어는 어디서든 대부분 쓰기 때문에 조금은 번거롭더라도 **중간 번역과정**을 한 번 거쳐두면 그 다음부터는 재사용을 하기도 쉽고 다른 언어로 번역하기도 쉽다는 장점을 살린 것처럼 프로그래밍에서도 이를 적용한 방식이 바로 하이브리드 방식이다.

어디서든 대부분 쓰일 수 있다는 것 == 플랫폼에 대해 독립적이다

먼저, 고급 언어로 작성된 소스코드를 바이트 코드(bytecode)로 변환한다. 바이트 코드란 일종의 중간 언어이다. 그리고 VM(Virtual Machine : 가상머신) 이라는 프로그램이 바이트코드를 기계어로 바꿔준다. VM은 하나의 프로그램을 VM 이라는 가상머신에서 실행한다고 보면 된다. 즉, 각 플랫폼에 맞는 VM들이 만들어져 있다면 같은 소스코드를 어느 플랫폼에서든지 동일한 결과를 얻어낼 수 있다.
**하이브리드 언어의 장점**

- 각 플랫폼에 지원하는 가상머신 있다면 실행 가능하기 때문에 플랫폼에 독립적이다.

**하이브리드 언어의 단점**

- 컴파일 언어처럼 하드웨어를 직접 제어하는 작업은 불가능하다.
