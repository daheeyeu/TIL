## Transaction 이란?

---

- C나 Java와 같은 프로그래밍 언어로 작성된 응용 프로그램은 명령어들의 집합으로 볼 수 있는데, 이러한 프로그램들은 세부적으로 여러 개의 함수나 클래스 단위로 구성된다. 함수나 클래스들은 전적으로 프로그래머가 프로그래밍의 편리성과 효율성 중심으로 설계한 결과물이다.
- 그러나 데이터베이스 응용프로그램에서는 프로그램의 구성을 다른 관점으로 살펴 볼 수 있다. 예를 들어 은행 업무에 관련된 데이터베이스 응용 프로그램을 가정했을 때, 이 프로그램은 계좌이체, 대출, 예금, 출금 등과 같이 은행에서 이루어지는 여러 가지 업무처리에 관련된 세부 프로그램들로 구성된다. 이러한 세부 프로그램들은 사용자 입장에서 보면 하나의 작업 단위가 됩니다. 그리고 이러한 작업들을 수행하기 위해서는 세부적으로 여러가지의 데이터베이스에 대한 연산(검색, 삽입, 삭제, 수정)들을 필요로 한다.
- 즉 트랜잭션이란 , 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

## **Transaction의 필요성**

---

- 트랜잭션을 정의하는 이유는 무엇일까? 그 동안 알지 못했지만, 우리는 현실에서 트랜잭션을 간접적으로 경험하고 있다. 계좌이체를 생각해보면 많은 사람들이 현금 인출기에서 카드를 이용하여 계좌이체를 한 경험이 있을 것이다. 이때 현금 인출기를 작동하는 도중에 기계오류나 정전 등과 같은 예기치 않은 상황이 발생하여 카드가 나오지 않거나 기계가 멈추는 경우가 있다. 이때 가장 우려되는 것이 내 계좌에서는 금액이 빠져나간 것으로 기록되고 정작 상대방 계좌에는 이체가 되지 않는 상황인데, 트랜잭션이란 바로 이러한 문제가 발생되지 않도록 하는 **강력한 수단을 제공**해주는 것입니다. 
즉, 내 계좌에서 금액이 빠져나가기 전 상태로 돌아가던지, 아니면 상대방 계좌로 이체가 성공적으로 끝나도록 보장해줘야 한다.
- 이 그림에서 A계좌에서 이체할 금액을 인출한 다음 B계좌에 이체된 금액을 저장하기 전에 어떠한 이유로 해서 실행이 중단되었다고 가정해보자. 즉, 그림에서 마지막 명령문 WRITE t 가 실행되지 않은 상황을 의미한다. 그러면 A계좌에는 이미 잔액이 인출된 결과가 저장되었지만, B계좌는 변경이 되지 않은 채로 남아있게 된다. 은행 업무에서 이러한 결과는 결코 발생되면 안된다. 즉, 계좌이체를 실행 할 때는 계좌이체에 **정의된 모든 연산을 완벽하게 실행**하던지, 아니면 **모두 실행하지 않고 처음의 상태로 남아있어야 합니다.**
- 또 다른 예로 은행에서 현금을 인출하는 과정을 살펴보면, 은행에서 예금을 인출하는 작업은 다음과 같은 연산으로 이루어진다.

**1. 예금 잔액을 확인한다.**

**2. 해당 인출금을 잔액에서 뺀다.**

**3. 인출금을 뺀 나머지를 새로운 잔액으로 저장한다.**

**4. 인출금을 지급한다.**
- 만약 현재 잔액이 500원인 계좌에 대해 두 사람이 각각 A지점과 B지점에서 동시에 100원을 인출하는 작업을 진행한다고 가정해 보자. 이 상황은 위 그림과 같다. 이 그림을 보면 우선 A와 B에서 예금 잔액을 읽고 동시에 그 값이 500원이라는 것을 확인 한다. 다음 두 지점에서 각각 잔액 500원에서 100원을 뺸다. 그러면 A와 B모두 잔액이 400으로 계산되어, 400원을 각각 저장합니다. 마지막으로 100원을 A와 b 모두에서 지급한다. 결국 A와 B지점에서 각각 100원씩 인출하여, 결국 200원을 인출한 셈이 되고 잔액은 400원이 된다. 이 상황도 올바르지 못하다. 이러한 오류의 원인은 A지점에서 잔액으로 400을 저장하였고, B지점에서도 400원을 저장함으로써, 둘 중 하나가 다른 지점에서 저장한 잔액을 덮어 써버렸기 때문이다. 결국 다중 사용자 환경에서 하나의 트랜잭션이 동시에 실행되는 다른 트랜잭션에 의해 영향을 받은 결과이다.
- 따라서 지금까지 예를 든 상황과 같이 원하지 않는 결과가 발생되지 않도록 사전에 방지하기 위해서 트랜잭션은 필요하다. 현재 대부분의 DBMS들은 이러한 상황을 방지하기 위한 기능을 갖추고 있습니다. 이를 위해 데이터베이스 개발자는 작업 단위들을 트랜잭션으로 적절히 정의해야 합니다. **즉, 트랜잭션을 정의하는 것은 전적으로 개발자의 의무이지만, 정의된 트랜잭션들에 대해서 위와 같은 문제가 발생하지 못하게 방지하는 것은 DBMS의 몫**이다.

## Transaction**의 특징**

---

**1.** 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다.

**2.** 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다.

**3.** 하나의 트랜잭션은 Commit되거나 Rollback된다.
Transaction의 성질(ACID)
### **Atomicity(원자성)**

**1.** 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

**2.** 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

### **Consistency(일관성)**

**1.** 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.

**2.** 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

### **Isolation(독립성,격리성)**

**1.** 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

**2.** 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

### **Durablility(영속성,지속성)**

**1.** 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
**위의 계좌 예시로 설명한 특징**

## Transaction ****연산 및 상태****

---

### **Commit연산**

**1.** Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

### **Rollback연산**

**1.** Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.

**2.** Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.

## Transaction****의 상태****
**활동(Active) :** 트랜잭션이 실행중인 상태

**실패(Failed) :** 트랜잭션 실행에 오류가 발생하여 중단된 상태

**철회(Aborted) :** 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

**부분 완료(Partially Committed) :** 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태

**완료(Committed) :** 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태
