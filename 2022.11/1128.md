## ☑️  해시란?

<aside>
🗣 **해시는 가변 길이의 데이터를 해시 함수를 사용해 고정 길이의 해시 값을 만들어 내는 방법이다.**

</aside>

**해시 함수 :** 임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 매핑하는 **단방향 함수**를 말한다. 쉽게 말해, 아무리 큰 숫자를 넣더라도 정해진 크기의 숫자가 나오는 함수이다.
- 매핑 전 원래 데이터 값을 키(Key)
- 매핑 후 데이터 값을 해시 값(Value)
- 해시 값 + 데이터의 색인 주소를 해시 테이블(Hash Table)
- 매핑하는 과정 자체를 해싱(hasing)

> key를 해시함수라는 함수에 Input으로 넣어서 Ouput으로 나오는 것이 `Hash(해시)`라고 생각하면 되고, 이 Hash(해시)가 저장위치 즉, 배열의 `index(인덱스)`로 변환된다고 생각하면 된다. `해시함수`는 key를 hash(해시)로 만들어내는 함수이다.
> 

## ☑️  해시함수의 특징

1. **방향 변환 알고리즘**
입력값을 압축하는 것이 아니라 입력값을 알 수 없도록 난수의 문자열로 변환이 된다. 따라서 양방향 변환 알고리즘과는 다르게 출력된 값을 토대로 원본 데이터를 복원할 수 없는 특징을 가지고 있다.
입력값 중에 한 글자만 바뀌거나 혹은 마침표(.) 하나만 들어가도 결과값이 완전히 달라진다는 임의성을 가지고 있다
이를 통해 입력값 혹은 원본 데이터의 사소한 변화도 한 번에 확인할 수 있기 때문에 위변조 판별이 쉽다.
hash는 데이터의 무결성을 검증하기 위해 사용한다. 최초 hash한 값과 비교해서 hash 값이 다르면 데이터가 변조되었다고 판단한다. 이처럼 입력에서의 작은 변화가 출력에서 큰 변화를 일으키는 것을 눈사태 효과라고 한다.
결과값이 정해진 길이로 나온다
예를들어 비트코인의 블록체인에 사용된 해시함수인 SHA-256은 입력값의 길이와 상관없이 결과값이 항상 256bit로 출력된다.
<aside>
🗣 해시함수가 제대로 작동하기 위해서는 일방향성과 충돌회피성이라는 두 가지 특징이 충족되어야 한다. 먼저 **일방향성**은 해시함수를 적용하여 나온 해시값을 이용하여 역으로 입력값을 찾는 것이 불가능하다는 특징이다.
**충돌회피성**이란 주어진 입력 값이 다르다면 동일한 출력값이 존재하지 않는다는 특징이다. 하지만 이론상 이 특성들을 완벽하게 갖추는 것은 불가능하기 때문에, 이 특성에 최대한 가까워지는 방향으로 해시함수가 기능해야 한다. 특히 입력값이 다르지만 결괏값이 같게 나오는 해시충돌을 최소화하는 것이 해시함수의 기능에 큰 영향을 미치기 때문에, 충돌을 최소화하는 것이 중요한 요소이다.

</aside>

## ☑️  해시함수의 활용

### 해시함수를 사용하는 이유

- **해시함수로 암호화한 값을 이용하여 입력값을 파악할 수 없다.**
- **출력(결과)값으로 입력값을 찾을 수 있는 복호화 공식이 없다.**
- **결과값이 중복될 가능성이 현저히 낮다.**

**1) 해시테이블**

> 해시함수가 가장 보편적으로 활용되는 곳은 해시 테이블이라는 자료 구조이다. 특정 데이터를 저장할 때, 해시함수로 계산을 수행한 후, 이 결괏값을 배열의 인덱스로 사용하여 저장하는 방식이다.
즉, 입력값을 해시함수 계산을 거쳐 나온 해시값을 기준으로 배열하기 때문에, 입력값의 길이에 상관없이 데이터 공간을 효과적으로 활용할 수 있다. 또 해시함수의 충돌회피성이라는 특성 덕분에 방대한 데이터에서 중복되는 것을 막아 테이블의 검색 속도를 높일 수 있다.
> 
- **해시 테이블의 사용 예시**
    
    ☑️ **해시 테이블로 조회하기**
    
    휴대폰의 전화번호부를 생각해보면,사람의 이름과 그 사람에 관련된 전화번호를 추가한다. 사람 이름을 입력하면 그 이름과 관련된 전화번호를 알려준다. 또는 메뉴판의 메뉴를 생각해보면, 메뉴 이름과 메뉴 가격을 추가한 후, 메뉴 이름을 입력하면 그 메뉴의 가격이 알려주는 메뉴판 역할을 해줄 수 있다.
    
    ☑️   **중복된 항목을 방지하기**
    
    투표소에서 어떤 사람이 투표를 했는가 안 했는가를 판단하기 위해서 배열이나 리스트를 사용하면 긴 목록을 뒤져봐야 하지만, 이름을 해시 테이블에 저장하면 해시 테이블에 이름이 있는지, 없는지 즉시 알려준다.
    
    ☑️  **해시 테이블을 캐시로 사용하기**
    
    캐싱은 작업 속도를 올리는 일반적인 방법이다. 모든 대형 웹사이트는 캐싱을 사용한다.그리고 그 자료는 바로 해시 테이블에 저장된다. 캐싱된 자료가 있으면 그 자료를 전송하고 없으면 서버에 요청하는 식으로 사용한다.
    

**2) 보안**

> 암호학에서는 해시함수의 일방향성의 특성을 활용할 수 있다. 해시함수의 연산 결과로 나온 해시값만으로는 원래 입력값을 알아내기 힘들기 때문에 사용자의 패스워드를 보관 등의 목적으로 활용할 수 있다. 패스워드를 입력값이 아닌 해시값으로 저장하고, 해시값만을 비교하여 접근 권한을 부여한다면 관리자도 입력값에 대한 정보가 없기 때문에 비밀번호 유출에 대한 위험이 줄어들게 된다.
>
비밀번호: 보통 유저의 비밀번호를 암호화해서 저장한다고 한다. 그러나 암호화의 경우는 복호화를 통해 실제 비밀번호를 알아낼 수 있으므로 암호화가 아닌 해시 함수를 이용해 생성된 해시 값을 저장해야한다.
**3) 블록체인**

> 블록체인 분야에서도 해시함수는 핵심적인 역할을 하고 있다. 블록체인은 일종의 공공거래장부로 거래내역이 하나의 블록을 형성하고 있는 형태이다. 이렇게 생성된 블록들은 순차적으로 쌓이는데 각각의 블록에는 이전 블록에 대한 정보를 가지고 있기 때문에 서로 연결된 구조이다. 이때 해시함수를 통해 서로 연결된 고리를 가지고 있는데, 만약 위조를 하기 위해 한 개의 블록에서 입력값을 변경한다면, 블록이 기존에 가지고 있던 해시값이 변경된다. 그렇기 때문에 연결된 블록 사이의 불일치가 발생하고, 이를 탐지하여 무결성을 보장하는데 해시함수를 이용할 수 있다.
> 
- 이외에도 해시 값만 가지고는 원본 데이터를 복원해내는 것은 불가능하므로 디지털자산의 전자지갑 주소,비밀번호, 전자서명, 전자투표, 전자상거래와 같은 민감한 입력의 무결성을 검증할 때 사용된다.

## ☑️  **해시테이블**

- `Hash Table`이란 **효율적인 key value lookup을 위해 key를 value에 매핑하는 자료 구조**이다. 찾는 과정을 살펴보면, 먼저 hash function(해시함수)을 사용해서 hash code값을 계산한다. key를 변환해서 더 작은 key로 만드는데 사용되는 함수가 hash function 인데, 그렇게 해서 얻어진 값인 hash(key) 값이 `hash code` 이다.
- 이 hash code를 array length로 나누어 얻어진 나머지를 index로 사용해서 해당 index에 매핑되는 value를 array에 저장하고 찾는 것이다.
- 예를 들어, [“apple”, “banana”, “lemon”] 이라는 key 배열이 있다고 가정하면 해시함수를 사용해서 hash code를 얻으면 각각 값이 4431541238040168687, 7306034771644922176, 3404778505129102945 이 된다. array의 length는 3이기 때문에 각각을 3으로 나눈 나머지는 0, 1, 1 이다. 그리고 이 값들이 index가 되어서 해당 index에 있는 value가 원래 key인 “apple”, “banana”, “lemon”에 매핑되는 값이다.
이 경우에서도 볼 수 있지만 hash code가 다르더라도 동일한 index가 나올 수 있다. 또한 서로 다른 key에 대해서 hash code 값이 같을 수도 있어서 이 경우에도 동일한 index가 나올 수 있다.

이를 보완하기 위해 Linear Probing 기법에서는 index가 겹치면 그 다음 index를 사용한다. 예를 들어, 아까처럼 “lemon”의 hash code를 3으로 나눈 나머지가 1로 “banana”의 index와 겹치면 1대신 2를 index로 사용한다.

이러한 충돌이 매우 높으면 worst case로는 런타임이 O(N)이 된다. (여기서 N은 key의 갯수) 그러나 일반적으로 충돌이 최소한으로 발생한다고 가정하여 look up 타임을 O(1)로 가정한다.

---

- 해쉬 테이블은 Key에 Value를 저장하는 데이터 구조이다.
- Key값으로 Value를 찾는데 O(1)시간에 작동한다.
- Key : 이름, Value : 전화 번호, Size : 16 일 경우,  John Smith이란 이름을 저장할 때 Key에 해당하는 Index를 찾는 방법은 해시 함수를 호출하면 된다.
- `Hash Function(“John Smith”)`–> 해시 함수안에서는 **해당 키값을 Size(=16)으로 나눠 Index를 반환**한다.
- 해시 함수를 통해 Index값을 구한 후 해당 위치에 Value를 저장한다.
- 이런 형식으로 데이터를 저장하면 Key에 해당하는 Value를 찾기위해 해시 함수를 1번만 수행하면 되기 때문에데이터의 **저장**과 **삭제**가 매우 빠르다.

### Hash table의 장단점

장점

- 데이터 저장/읽기 속도가 빠르다. → 검색 속도가 빠르다.
- 해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉽다.
- 충돌이 없다면 해쉬테이블은 시간복잡도 O(1)로 짧다!

단점

- 일반적으로 저장공간이 더 많이 필요하다.
- 여러 키에 해당하는 주소가 동일한 경우 충돌을 해결하기 위한 별도 자료구조가 필요하다.
- 데이터 충돌이 발생한다면 체이닝(Chaining)에 연결된 리스트들까지 모두 검색을 해야 하므로 O(N)까지 시간복잡도가 증가할 수 있다.
`체이닝(Chaining` : 자료 저장 시, 저장소(bucket)에서 충돌이 일어나면 해당 값을 기존 값과 연결시키는 기법

## ☑️  해시충돌(collison)이란?

만약 A,B 두가지 key가 있다고 하자. A와 B를 hash function으로 해시 값을 얻었는데 hash값이 2로 똑같이 나왔다. 이런 현상을 `해쉬 충돌` 이라고 한다.

해시 함수로 해시를 만드는 과정에서 서로 다른 key가 같은 해시로 변경되면 같은 공간에 2개의 value가 저장되므로 key-value가 1:1로 매핑되어야 하는 해시 테이블의 특성에 위배된다.

통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.

**해쉬충돌의 문제점**을 정리하자면,

1) Hashing을 해서 삽입하려 했으나 이미 다른 원소가 자리를 차지하고 있는 상황 발생
2) 충돌은 해싱의 검색 속도를 떨어뜨리게 하여 버킷의 크기를 넘어 저장하게 되어 오버플로우 발생

3) 인덱스를 한정된 인덱스로 바꾸게 된다면 다른 해시코드라도 같은 인덱스가 나올 수 있는 경우가 생길 수 있습니다. (혹은 완전히 같은 해시코드가 나올 수도 있습니다.) 이런 경우 충돌(collision)이 발생했다고 하는데, 이 충돌을 어떤식으로 해결하는지 여러가지 방법이 있습니다. 이 포스팅에서는 분리 체인법을 설명하도록 하겠습니다. (다른 방법들로는 선형 탐사, 2차 탐사, 이중해싱등이 있습니다.)

+ 이러한 이유로 자바에서 hashCode()를 오버라이딩 할 때 단짝처럼 equals()도 오버라이딩 해야합니다. 별개의 객체가 우연히 해시코드가 똑같이 나오게 되더라도, equals()로 값의 동등성을 한번 더 확인 하는 과정을 거치게 되면 충돌을 방지 할 수 있습니다.

### Hash collision 해결 알고리즘

**1) Separate Chaining 기법(폐쇄형)** : 각 인덱스에 할당된 것이 값이 아니라 키와 값을 가진 **LinkedList(연결리스트)로 추가적인 공간을 활용**하는 것
Sandra가 들어가는데 충돌이 일어나니 기존에 있던 John의 값에 연결시켰다. 체이닝(Chaining)은 자료 저장 시, 저장소(bucket)에서 충돌이 일어나면 해당 값을 기존 값과 연결시키는 기법이다. 위의 사진에서 Sandra를 저장할 때 충돌이 일어났고, 기존에 있던 John에 연결시켰다. 이 때 **연결리스트(Linked List) 자료구조를 이용**한다. 해쉬충돌이 일어날 때 `다음에 저장된 자료를 기존의 자료 다음에 위치시키는 것`이다.

**Separate Chaining 장단점**

장점 :
1) 한정된 저장소(Bucket)을 효율적으로 사용할 수 있다.
2) 해시 함수(Hash Function)을 선택하는 중요성이 상대적으로 적다.
3) 상대적으로 적은 메모리를 사용한다. 미리 공간을 잡아 놓을 필요가 없다.

단점 :
1) 한 Hash에 자료들이 계속 연결된다면(쏠림 현상) 검색 효율이 낮아질 수 있다.
2) 외부 저장 공간을 사용한다.
3) 외부 저장 공간 작업을 추가로 해야 한다.

**2) Open Addressing 기법(개방형)** : 충돌 발생시, **인접한 다른 비어있는 해시 버킷을 찾아 삽입**하는 방법
Open Addressing(개방주소법)에서의 해시테이블은 1개의 해시와 1개의 값(value)가 매칭되어 있는 형태로 유지된다. 위의 그림을 보면, Sandra가 저장될때 해시가 John으로 채워져 있어서 그 다음 Hash에 Sandra를 저장했다. 그리고 Ted의 해시도 Sandra가 저장되어 있으므로 그 다음 해시에 Ted를 저장했다. 이처럼 비어있는 해시를 찾아 저장하는 방법을 Open Addressing라고 한다.

이 때, 비어있는 해시(Hash)를 찾는 과정은 동일해야 한다.(일정한 규칙을 따라 찾아가야 한다.)

`i: index`

- 선형 탐색(Linear Probing): `고정폭`으로 이동 : 다음 해시(+1)나 i개(+i)를 건너뛰어 비어있는 버킷에 데이터를 저장한다. 단, 군집현상이 일어나기 쉽다.
- 제곱 탐색(Quadratic Probing): `제곱수`로 이동 : 충돌이 일어난 해시에서 제곱(+i^2)나 ((i+1)^2)을 한 비어있는 곳의 버킷에 데이터를 저장한다.

**Open Addressing의 장단점**

장점:
1) 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다.
2) 또 다른 저장공간에서의 추가적인 작업이 없다.

단점:
1) 해시 함수(Hash Function)의 성능에 전체 해시테이블의 성능이 좌지우지된다.
2) 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 두어야 한다.

## ☑️  **해시 함수의 문제점**

- 해시함수의 특징 중 자원소모가 적어 처리속도가 빠르다고 했지만, 이건 장점이자 단점인데,무차별 대입 공격을 받을 수 있기 때문이다. (해시값이 암호라고 하면, 암호를 찾기위해 해시함수에 무차별적으로 값을 대입해서 찾으려고 할 수 있다는 말 같다.)
- 레인보우 테이블 공격: 해시함수(MD-5, SHA-1, SHA-2)를 사용하여 만들어낼 수 있는 값들을 대량으로 저장한 표다. MD-5가 쉽게 복호화될 수 있다는 것을 보여준 해킹비법 중 하나이다. 이 얘기는 결과로 나올 수 있는 해시값들을 저장해놓고, input을 대입해가면서 해시를 예측하는 방법인 것 같다.

> MD-5 (Message-Digest algorithm 5)
> 
> - 임의의 길이를 입력받아 128bit 길이의 해시값을 출력한다.
> - 단방향 알고리즘
> - 현재는 심각한 보안문제로 인하여 MD5를 보안 관련 용도로 사용하지 않는다.
> - 2008년에는 MD5의 결함을 이용해 SSL 인증서를 변조하는 것이 발견되었다.

## ☑️  자바에서 사용하는 Hash

HashTable이란 JDK 1.0부터 있던 Java의 API이고, HashMap은 Java2에서 처음 선보인 Java Collections Framework에 속한 API이다. HashTable 또한 Map 인터페이스를 구현하고 있기때문에 HashMap과 HashTable이 제공하는 기능은 같다.

### 차이점(HashMap vs HashTable)

- **보조 해시 함수**
HashMap은 보조 해시함수를 사용하기 때문에 보조 해시 함수를 사용하지 않는 HashTable에 비하여 **해시 충돌(hash collision)이 덜 발생**할 수 있어 상대적으로 성능상 이점이 있다.
- **동기화**
`HashMap의 경우 동기화를 지원하지 않는다.` 그래서 Hash Table은 동기화 처리라는 비용때문에 HashMap에 비해 더 느리다고 한다. 프로그래밍상의 편의성 때문에 멀티쓰레드 환경에서도 HashTable을 쓰기보다는 HashMap을 다시 감싸서 `Map m == Collections.syschronizedMap(new HashpMap());` 과 같은 형태가 더 선호된다.
    
    ```java
    // 해시테이블의 put
    public synchronized V put(K key, V value) {
    // Make sure the value is not nullif (value == null) {
            throw new NullPointerException();
        }
    // Makes sure the key is not already in the hashtable.
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        Entry<K,V> entry = (Entry<K,V>)tab[index];
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) && entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }
        addEntry(hash, key, value, index);
        return null;
    }
    
    // 해시맵의 put
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    ```
    
    위의 코드에서 첫번째 put은 해시테이블의 put이며, 두번째 put은 해시맵의 put이다. 첫번째 해시테이블의 put에는 `synchronized` 키워드가 붙어있는 것을 확인할 수 있는데, 이것은 병렬 프로그래밍을 할 때 동기화를 지원해준다는 것을 의미한다. 이것은 해당 함수를 처리하는 시간이 조금 지연됨을 의미힌다.
    
    그렇기 때문에 우리는 병렬 처리를 하면서 자원의 동기화를 고려해야 하는 상황이라면 해시테이블(HashTable)을 사용해야 하며, 병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 해시맵(HashMap)을 사용하면 된다.
    

### HashMap

- HashMap의 작동 방식은?
HashMap의 내부는 배열로 이루어져 있다. HashMap은 Key-Value 형식이기 때문에, Key는 배열의 인덱스가 되고, 이 배열은 해시 버킷이다.

먼저 key값을 hashcode()라는 메소드를 통해 int형의 해쉬값으로 바꾸고 이를 버킷의 사이즈인 M으로 나눈 나머지가 해시 버킷의 진짜 인덱스가 된다.`int index = hashcode() % M;`

HashMap에서 사용하는 충돌기법 방식은 **Seaparate Chaining** 이다. Open Addressing은 데이터를 삭제할 때 처리가 효율적이기 어려운데 HashMap에서 remove()메서드는 비번하게 호출될 수 있기 때문이다.

게다가 HashMap에 저자된 key-value 쌍 개수가 일정 개수 이상으로 많아지면, 일반적으로 Open Addressing은 Separate Chaining보다 느리다. Open Addressing은 버킷의 밀도가 높아질수록 Worst Case 빈도가 높아지지만, Chaining은 해시 출동이 잘 발생하지 않도록 조정하면 Worst Case를 줄일 수 있다.

**자바 8부터는** Seperate Chaining에서 데이터 개수가 많아지면 LinkedList대신 Tree(`red black tree`)를 사용해 성능적으로 더 좋아지게 하였다. 즉, 처음에는 해시 버킷을 LinkedList로 하고 8개 이상의 키-값 쌍이 모이면 LinkedList(`O(N)`)를 Tree(`O(logN)`)구조로 바꾼다. 만약 데이터가 삭제되어 버킷이 6개에 이르게 되면 다시 LinkedList 구조로 변경한다.

HashMap은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면, 해시 버킷의 수를 두배로 늘린다. 해시 버킷의 수를 늘려서 해시 충돌의 확률을 줄이는 것이다.

### hashMap의 시간복잡도

- 일반적으로 충돌을 최소화하도록 잘 구현된 경우 : `O(1)`
- 충돌이 자주 발생하는 경우(최악의 경우) : `O(N)`
- 균형 이진 탐색 **트리**를 사용한 경우 : `O(logN)` 
이 방법은 배열의 크기를 미리 할당해 놓지 않아도 되기 때문에 잠재적으로 적은 공간을 사용하고, 키의 집합을 특정 순서로 차례대로 접근할 수 있다.
